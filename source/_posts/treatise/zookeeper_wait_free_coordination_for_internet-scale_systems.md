---
title: ZooKeeper Wait-free coordination for Internet-scale systems 中文翻译版
date: 2021-07-05 22:26:13
tags:
- "论文"
- "Zookeeper"
id: zookeeper_wait_free_coordination_for_internet-scale_systems
no_word_count: true
no_toc: false
categories: 大数据
---

## ZooKeeper: Wait-free coordination for Internet-scale systems 中文翻译版

作者：

Patrick Hunt、Mahadev Konar、Flavio P. Junqueira、Benjamin Reed

### 摘要

在本文中，我们描述了 ZooKeeper，一种用于协调分布式应用程序进程的服务。
由于 ZooKeeper 是关键基础设施的一部分，ZooKeeper 旨在提供一个简单且高性能的内核，用于在客户端构建更复杂的协调原语。
它在一个复制的、集中的服务中整合了来自群消息传递、共享寄存器和分布式锁服务的元素。
ZooKeeper 公开的接口具有共享寄存器的免等待特性，具有类似于分布式文件系统的缓存失效机制的事件驱动机制，以提供简单而强大的协调服务。

ZooKeeper 接口支持高性能服务实现。
除了无等待属性之外，ZooKeeper 还为每个客户端保证请求的 FIFO 执行和所有更改 ZooKeeper 状态的请求的线性化。
这些设计决策可以实现高性能处理管道并使本地服务器可以满足读取请求。
对于目标工作负载，2:1 到 100:1 的读写比率，ZooKeeper 每秒可以处理数万到数十万个事务。
这种性能允许客户端应用程序广泛使用 ZooKeeper。

### 1 引言

大规模分布式应用需要不同形式的协调服务。
配置是最基本的协调形式之一。
在最简单的形式中，配置只是系统进程的操作参数列表，而更复杂的系统具有动态配置参数。
组成员和领导者选举在分布式系统中也很常见：进程通常需要知道哪些其他进程还活着以及这些进程负责什么。
锁构成了一个强大的协调原语，它实现了对关键资源的互斥访问。

一种协调方法是为每个不同的协调需求开发服务。
例如，Amazon Simple Queue Service `[3]` 专门关注队列。
其他服务是专门为领导选举 `[25]` 和配置 `[27]` 开发的。
实现更强大原语的服务可用于实现功能较弱的原语。
例如，Chubby `[6]` 是一个具有强同步保证的锁定服务。
然后可以使用锁来实现领导者选举、组成员资格等。

在设计我们的协调服务时，我们不再在服务器端实现特定的原语，而是选择公开一个 API，使应用程序开发人员能够实现他们自己的原语。
这样的选择导致了协调内核的实现，该内核支持新的原语，而无需更改服务核心。
这种方法支持适应应用程序要求的多种形式的协调，而不是将开发人员限制在一组固定的原语中。

在设计我们的协调服务时，我们不再在服务器端实现特定的原语，而是选择公开一个 API，使应用程序开发人员能够实现他们自己的原语。
这样的选择导致了协调内核的实现，该内核支持新的原语，而无需更改服务核心。
这种方法支持适应应用程序要求的多种形式的协调，而不是将开发人员限制在一组固定的原语中。

在设计 ZooKeeper 的 API 时，我们远离了阻塞原语，例如锁。
协调服务的阻塞原语可能会导致慢速或故障客户端等问题，从而对更快客户端的性能产生负面影响。
如果处理请求依赖于其他客户端的响应和故障检测，则服务本身的实现会变得更加复杂。
因此，我们的系统 Zookeeper 实现了一个 API，该 API 可以操作简单的无等待数据对象，就像在文件系统中一样分层组织。
实际上，ZooKeeper API 类似于任何其他文件系统，仅从 API 签名来看，ZooKeeper 似乎是没有锁定方法、打开和关闭的 Chubby。
然而，实现免等待数据对象将 ZooKeeper 与基于阻塞原语(例如锁)的系统区分开来。

尽管无等待属性对于性能和容错很重要，但对于协调来说还不够。
我们还必须为运营提供订单保证。
特别是，我们发现保证所有操作的 FIFO 客户端排序和线性化写入可以有效实现服务，并且足以实现我们的应用程序感兴趣的协调原语。
事实上，我们可以使用我们的 API 为任意数量的进程实现共识，并且根据 Herlihy 的层次结构，ZooKeeper 实现了一个通用对象 `[14]`。

ZooKeeper 服务包含一组使用复制来实现高可用性和性能的服务器。
其高性能使包含大量进程的应用程序能够使用这样的协调内核来管理协调的所有方面。
我们能够使用简单的流水线架构来实现 ZooKeeper，该架构允许我们处理成百上千个未完成的请求，同时仍然实现低延迟。
这样的管道自然能够以 FIFO 顺序从单个客户端执行操作。
保证 FIFO 客户端顺序使客户端能够异步提交操作。
通过异步操作，客户端一次可以有多个未完成的操作。
例如，当新客户端成为领导者并且必须操作元数据并相应地更新它时，此功能是可取的。
没有多个未完成操作的可能性，初始化时间可以是秒级而不是亚秒级。

为了保证更新操作满足线性化，我们实现了一个基于领导者的原子广播协议 `[23]`，称为 Zab `[24]`。
然而，ZooKeeper 应用程序的典型工作负载由读取操作主导，因此需要扩展读取吞吐量。
在 ZooKeeper 中，服务器在本地处理读操作，我们不使用 Zab 对它们进行完全排序。

在客户端缓存数据是提高读取性能的一项重要技术。
例如，一个进程缓存当前领导者的标识符而不是每次需要知道领导者时探测 ZooKeeper 是有用的。
ZooKeeper 使用监视机制使客户端能够缓存数据，而无需直接管理客户端缓存。
通过这种机制，客户端可以监视给定数据对象的更新，并在更新时收到通知。
Chubby 直接管理客户端缓存。
它阻止更新以使所有缓存正在更改的数据的客户端的缓存无效。
在这种设计下，如果这些客户端中的任何一个运行缓慢或出现故障，更新就会延迟。
Chubby 使用租约来防止有故障的客户端无限期地阻塞系统。
然而，租约只能限制慢速或故障客户端的影响，而 ZooKeeper watches 则完全避免了这个问题

在本文中，我们将讨论 ZooKeeper 的设计和实现。
使用 ZooKeeper，我们能够实现应用程序所需的所有协调原语，即使只有写入是可线性化的。
为了验证我们的方法，我们展示了我们如何使用 ZooKeeper 实现一些协调原语。

总之，在本文中我们主要贡献有：

**协调内核**：
我们提出了一种在分布式系统中使用具有宽松一致性保证的无等待协调服务。
特别是，我们描述了协调内核的设计和实现，我们已在许多关键应用程序中使用它来实现各种协调技术。

**协调清单**：
我们展示了如何使用 ZooKeeper 来构建更高级别的协调原语，甚至是分布式应用程序中经常使用的阻塞和强一致性原语。

**协调经验**：
分享一些 ZooKeeper 的使用方法，并对其性能进行评估。

### 2 ZooKeeper 服务

客户端使用 ZooKeeper 库通过 API 向 ZooKeeper 提交请求。
除了通过 API 暴露 ZooKeeper 服务接口之外，客户端库还管理客户端和 ZooKeeper 服务器之间的网络连接。

在本节中，我们首先从架构来概览 ZooKeeper 服务。
然后我们讨论客户端用来与 ZooKeeper 交互的 API。

**术语**
在本文中，我们使用 client 表示 ZooKeeper 服务的用户，server 表示提供 ZooKeeper 服务的进程，znode 表示 ZooKeeper 数据中的内存数据节点，
它组织在一个分层的命名空间中，称作为数据树。
我们还使用术语更新和写入来指代任何修改数据树状态的操作。
客户端在连接到 ZooKeeper 并获取会话句柄时建立会话，并通过该句柄发出请求。

#### 2.1 服务概览

ZooKeeper 向其客户端提供一组数据节点 (znodes) 的抽象，根据分层名称空间进行组织。
此层次结构中的 znode 是客户端通过 ZooKeeper API 操作的数据对象。
分层命名空间通常用于文件系统。
这是一种组织数据对象的理想方式，因为用户习惯于这种抽象，并且它可以更好地组织应用程序元数据。
为了引用给定的 znode，我们对文件系统路径使用标准的 UNIX 表示法。
例如，我们使用 /A/B/C 来表示 znode C 的路径，其中 C 有 B 作为其父级，B 有 A 作为其父级。
所有 znode 都存储数据，所有 znode，除了临时 znode，都可以有子节点。

客户端可以创建两种类型的 znode：

**常规型(Regular)**：客户端通过显式创建和删除它们来操作常规 znode。
**临时型(Ephemeral)**：客户端创建这样的 znode，他们要么明确删除它们，要么让系统在创建它们的会话终止时自动删除它们(故意或由于故障)。

此外，在创建新的 znode 时，客户端可以设置一个顺序标志。
使用顺序标志集(sequential flag)创建的节点具有附加到其名称的单调递增计数器的值。
如果 n 是新的 znode 并且 p 是父节点，则 n 的序列值永远不会小于在 p 下创建的任何其他顺序 znode 的名称中的值。

ZooKeeper 实现了 watches 以允许客户端及时接收更改通知而无需轮询。
当客户端发出设置了监视标志的读取操作时，该操作将正常完成，除非服务器承诺在返回的信息发生更改时通知客户端。
watches 是与会话相关的一次性触发器；一旦触发或会话关闭，它们将被取消注册。
watches 指示发生了更改，但不提供更改。
例如，如果客户端在 “/foo” 更改两次之前发出 getData(“/foo”, true)，客户端将收到一个监视事件，告诉客户端 “/foo” 的数据已更改。
例如连接丢失事件一样的会话事件，也被发送到 watches 回调，以便客户端知道 watches 事件可能会有延迟。

**数据模型**
ZooKeeper 的数据模型本质上是一个 API 简化的文件系统，只有完整的数据读写，或者是一个具有层次化的键/值表。
分层命名空间对于为不同应用程序的命名空间分配子树以及设置对这些子树的访问权限非常有用。
我们还利用客户端目录的概念来构建更高级别的原语，我们将在 2.4 节中看到。

![图 1：ZooKeeper 分层名称空间的图示](https://i.loli.net/2021/07/06/vTYRiDhJajWxSmn.png)

与文件系统中的文件不同，znode 不是为一般数据存储而设计的。
相反，znode 映射到客户端应用程序的抽象，通常对应于用于协调目的的元数据。
为了说明这一点，在图 1 中，我们有两个子树，一个用于应用程序 1 (/app1)，另一个用于应用程序 2 (/app2)。
应用程序 1 的子树实现了一个简单的组成员协议：每个客户端进程 p_i 在 /app1 下创建一个 znode pi，只要进程正在运行，它就会一直存在。

尽管 znodes 不是为一般数据存储而设计的，但 ZooKeeper 确实允许客户端存储一些可用于分布式计算中的元数据或配置的信息。
例如，在基于领导者的应用程序中，这对于刚刚开始了解哪个其他服务器当前是领导者的应用程序服务器很有用。
为了实现这个目标，我们可以让当前的领导者将这些信息写在 znode 空间中的一个已知位置。
znode 还具有与时间戳和版本计数器相关联的元数据，这允许客户端跟踪对 znode 的更改并根据 znode 的版本执行条件更新。

**会话**
客户端连接到 ZooKeeper 并发起会话。
会话在到达配置的事件后会超时。
如果 ZooKeeper 在超过该超时时间而没有从其会话中收到任何内容，则认为客户端有故障。
当客户端明确关闭会话 handle 或 ZooKeeper 检测到客户端故障时，会话关闭。
在会话中，客户端观察反映其操作执行的一系列状态变化。
会话使客户端能透明地在 ZooKeeper 集合内从一台服务器移动到另一台服务器，而不中断服务。

#### 2.2 客户端 API

我们在下面介绍 ZooKeeper API 的一个相关子集，并讨论每个请求的语义。

**create(path, data, flags)**：
创建一个 znode 将其路径名设置为 path 并存储 data[] 数据，然后返回新 znode 的名称。
flags 标识能让客户端选择 znode 的类型，具体是常规型还是临时型。

**delete(path, version)**：
如果 znode 处于预期版本，则删除 znode 路径。

**exists(path, watch)**：
如果具有路径名 path 的 znode 存在，则返回 true，否则返回 false。
watch 标志使客户端能够在 znode 上设置监视。

**getData(path, watch)**：
返回与 znode 关联的数据和元数据，例如版本信息。
watch 标志的工作方式与它对exists() 的工作方式相同，除了如果znode 不存在ZooKeeper 不会设置监视。

**setData(path, data, version)**：
如果版本号是 znode 的当前版本，则将 data[] 写入 znode 路径。

**getChildren(path, watch)**：
返回 znode 子节点的名称集。

**sync(path)**:
等待所有挂起的更新操作开始传播向客户端所连接的服务器。
该路径当前被忽略。

> 注：即等待所有待完成的更新操作完成更新，但是忽略输入路径。

所有方法都在 API 中提供了同步和异步版本。
应用程序在需要执行单个 ZooKeeper 操作并且没有并发任务要执行时使用同步 API，因此它会进行必要的 ZooKeeper 调用并阻塞。
然而，异步 API 使应用程序能够同时执行多个未完成的 ZooKeeper 操作和其他任务。
ZooKeeper 客户端保证按顺序调用每个操作的相应回调。

值得注意的是，ZooKeeper 不使用 handle 来访问 znode。
每个请求都包含正在操作的 znode 的完整路径。
这种选择不仅简化了 API(没有 open() 或 close() 方法)，而且还消除了服务器需要维护的额外状态。

每个更新方法都采用一个预期的版本号，这使得有条件更新的实现成为可能。
如果 znode 的实际版本号与预期版本号不匹配，则更新失败并出现意外版本错误。
如果版本号为 -1，则不执行版本检查。

#### 2.3 ZooKeeper 保证

ZooKeeper 有两个基本的排序保证：

**可线性写入**：
所有更新 ZooKeeper 状态的请求都是可序列化的并尊重优先级。

**先进先出的客户端顺序**：
来自给定客户端的所有请求都按照客户端发送的顺序执行。

请注意，我们对线性化的定义与 Herlihy `[15]` 最初提出的定义不同，我们称之为 A-线性化(异步线性化)。
在 Herlihy 对线性化的最初定义中，一个客户端一次只能有一个未完成的操作(一个客户端是一个线程)。
在我们的情况下，我们允许一个客户端有多个未完成的操作，因此我们可以选择让同一客户端的未完成操作无须的或按照 FIFO 顺序执行。
为了符合设计需求我们选择了后者。
重要的是要观察到所有适用于可线性化对象的结果也适用于 A 可线性化对象，因为满足 A-线性化的系统也同时满足了线性化。
因为只有更新请求是 A-线性化，所以 ZooKeeper 在每个副本本地处理读取请求。
这允许服务随着服务器添加到系统而线性的进行扩张。

要了解这两种保证如何相互作用，请考虑以下场景。
由多个进程组成的系统会选举一个领导者来指挥工作进程。
当新的领导者接管系统时，它必须更改大量配置参数并在完成后通知其他进程。
然后我们有两个重要的要求：

- 当新的领导开始修改内容时，我们不希望其它的进程使用正在修改的配置。
- 如果新的领导者在配置完全更新之前死亡，我们不希望其它进程使用这个部分配置。

请注意，分布式锁(例如 Chubby 提供的锁)将有助于满足第一个要求，但不足以满足第二个要求。
有了 ZooKeeper，新的领导者可以指定一条路径作为 ready znode；其他进程只会在该 znode 存在时使用该配置。
新的 leader 通过删除 ready、更新各种配置znode、重新创建 ready 来改变配置。
所有这些变动都可以通过管道进行异步发布，以快速更新配置状态。
尽管更改操作的延迟在 2 毫秒的数量级，但如果请求一个接一个地发出，更新 5000 个不同 znode 的新领导者将花费 10 秒；
如果通过异步发出请求，则可以在 1 秒钟之内完成。
由于顺序保证，如果一个进程看到 ready znode，它也必须看到新领导者所做的所有配置更改。
如果在创建 ready znode 之前新领导者死亡，则其他进程知道配置尚未最终确定并且不会使用它。

上述方案仍然有一个问题：如果一个进程在新的领导者开始进行更改之前看到 ready znode 存在，然后在更改正在进行时开始读取配置会发生什么。
这个问题是通过通知的顺序保证来解决的：如果客户端正在观察更改，客户端将在看到更改后系统的新状态之前看到通知事件。
因此，如果读取 ready znode 的进程请求收到有关该 znode 更改的通知，它将在读取任何新配置之前看到客户端更改的通知。

当客户端除了 ZooKeeper 之外还有自己的通信通道时，会出现另一个问题。
例如，考虑两个客户端 A 和 B，它们在 ZooKeeper 中具有共享配置并通过共享通信通道进行通信。
如果 A 更改 ZooKeeper 中的共享配置并通过共享通信通道告诉 B 更改，B 将期望在重新读取配置时看到更改。
如果 B 的 ZooKeeper 副本稍微落后于 A，则它可能看不到新配置。
使用上述保证 B 可以通过在重新读取配置之前发出写入来确保它看到最新的信息。

为了更有效地处理这种情况，ZooKeeper 提供了 sync 请求：跟随进行读取的操作被称为慢读。
sync 使得服务器先完成读取请求然后再完成所有等待的写入请求而没有产生完全写入的开销。
这个原语在思想上类似于 ISIS `[5]` 的 flush 。

ZooKeeper 还具有以下两个活动性和持久性保证：
如果大多数 ZooKeeper 服务器处于活动状态则通信服务将可用；
如果 ZooKeeper 服务成功响应更改请求，则只要仲裁服务器最终能够恢复，该更改就会在任何数量节点的故障中正常恢复。

#### 2.4 原语的例子

在本节中，我们将展示如何使用 ZooKeeper API 来实现更强大的原语。
ZooKeeper 服务对这些更强大的原语一无所知，因为它们完全在客户端使用 ZooKeeper 客户端 API 实现。
一些常见的原语，如组成员资格和配置管理，也是免等待的。
对于其他的，比如集合点，客户端需要等待一个事件。
即使 ZooKeeper 是无等待的，我们也可以使用 ZooKeeper 实现高效的阻塞原语。
ZooKeeper 的排序保证允许对系统状态进行有效推理，而 watches 则允许有效等待。

**配置管理**
ZooKeeper 可用于在分布式应用程序中实现动态配置管理。
配置以最简单的形式存储在 znode Z<sub>c</sub> 中。
进程以 Z<sub>c</sub> 的完整路径名启动。
启动进程通过读取 zc 并将 watch 标志设置为 true 来获取它们的配置。
如果 zc 中的配置被更新，进程会收到通知并读取新配置，再次将 watch 标志设置为 true。

请注意，在此方案中，与大多数其他使用 watch 的方案一样，确保进程具有最新信息。
例如，如果一个正在观察 Z<sub>c</sub> 的进程收到 Z<sub>c</sub> 更改的通知，并且在它可以为 Z<sub>c</sub> 发出读取之前，
还有三个 Z<sub>c</sub> 更改，则该进程不会收到另外三个通知事件。
这不会影响进程的行为，因为这三个事件只会通知进程它已经知道的事情：它拥有的关于 Z<sub>c</sub> 的信息是陈旧的。

**集合**
有时在分布式系统中，最终系统配置的外观并不总是先验清楚的。
客户端可能想要启动一个主进程和几个工作进程，但是启动进程是由调度程序完成的，因此客户端不知道它可以给工作进程连接到主进程的地址和端口等信息。
我们通过 ZooKeeper 使用客户端创建的集合点 znode Z<sub>r</sub> 来处理这种情况。
客户端将 Z<sub>r</sub> 的完整路径名作为主进程和工作进程的启动参数进行传递。
当主进程启动时，它会在 Z<sub>r</sub> 中填入有关它正在使用的地址和端口的信息。
当工作进程启动时，它会在 watch 设置为 true 的情况下读取 Z<sub>r</sub> 。
如果 Z<sub>r</sub> 尚未填写，则工作进程会等待 Z<sub>r</sub> 更新时收到通知。
如果 Z<sub>r</sub> 是一个临时节点，主进程和工作进程可以监视 Z<sub>r</sub> 的删除并在客户端结束时清理自己。

**组关系**
我们利用临时节点来实现组成员身份。
具体来说，我们使用临时节点允许我们查看创建节点的会话状态这一事实。
我们首先指定一个 znode Z<sub>g</sub> 来表示该组。
当组的进程成员启动时，它会在 Z<sub>g</sub> 下创建一个临时子 znode。
如果每个进程都有唯一的名称或标识符，则该名称将用作子 znode 的名称；否则，该进程会使用 SEQUENTIAL 标志创建 znode 以获得唯一的名称分配。
例如，进程可以将进程信息放入子 znode 的数据中，例如进程使用的地址和端口。

在 Z<sub>g</sub> 下创建子 znode 后，进程正常启动。
它不需要做任何其他事情。
如果进程失败或结束，在 Z<sub>g</sub> 下代表它的 znode 将被自动删除。

进程可以通过简单地列出 Z<sub>g</sub> 的子进程来获取组信息。
如果进程想要监视组成员身份的更改，则该进程可以将监视标志设置为 true 并在收到更改通知时刷新组信息(始终将监视标志设置为 true)。

**简单的锁**
ZooKeeper 虽然不是锁服务，但是可以用来实现锁。
使用 ZooKeeper 的应用程序通常使用根据其需要定制的同步原语，如上所示。
这里我们展示了如何使用 ZooKeeper 实现锁，以表明它可以实现多种通用同步原语。

最简单的锁实现使用 “锁文件”。
锁由一个 znode 表示。
为了获取锁，客户端尝试使用 EPHEMERAL 标志创建指定的 znode。
如果创建成功，客户端持有锁。
否则，如果当前领导者死亡，客户端可以读取设置了监视标志的 znode 以得到通知。
客户端在死亡或显式删除 znode 时释放锁。
等待锁的其他客户端一旦观察到 znode 被删除，就会再次尝试获取锁。

虽然这个简单的锁定协议有效，但它确实存在一些问题。
首先，它受到羊群效应(herd effect)的影响。
如果有很多客户端在等待获取锁，即使只有一个客户端可以获取锁，他们也会在锁被释放时争夺锁。
其次，它只实现了排他锁。
以下两个原语展示如何克服这两个问题。

**解决羊群效应简单锁**