---
title: ZooKeeper Wait-free coordination for Internet-scale systems 中文翻译版
date: 2021-07-05 22:26:13
tags:
- "论文"
- "Zookeeper"
id: zookeeper_wait_free_coordination_for_internet-scale_systems
no_word_count: true
no_toc: false
categories: 大数据
---

## ZooKeeper: Wait-free coordination for Internet-scale systems 中文翻译版

作者：

Patrick Hunt、Mahadev Konar、Flavio P. Junqueira、Benjamin Reed

### 摘要

在本文中，我们描述了 ZooKeeper，一种用于协调分布式应用程序进程的服务。
由于 ZooKeeper 是关键基础设施的一部分，ZooKeeper 旨在提供一个简单且高性能的内核，用于在客户端构建更复杂的协调原语。
它在一个复制的、集中的服务中整合了来自群消息传递、共享寄存器和分布式锁服务的元素。
ZooKeeper 公开的接口具有共享寄存器的免等待特性，具有类似于分布式文件系统的缓存失效机制的事件驱动机制，以提供简单而强大的协调服务。

ZooKeeper 接口支持高性能服务实现。
除了无等待属性之外，ZooKeeper 还为每个客户端保证请求的 FIFO 执行和所有更改 ZooKeeper 状态的请求的线性化。
这些设计决策可以实现高性能处理管道并使本地服务器可以满足读取请求。
对于目标工作负载，2:1 到 100:1 的读写比率，ZooKeeper 每秒可以处理数万到数十万个事务。
这种性能允许客户端应用程序广泛使用 ZooKeeper。

### 1 引言

大规模分布式应用需要不同形式的协调服务。
配置是最基本的协调形式之一。
在最简单的形式中，配置只是系统进程的操作参数列表，而更复杂的系统具有动态配置参数。
组成员和领导者选举在分布式系统中也很常见：进程通常需要知道哪些其他进程还活着以及这些进程负责什么。
锁构成了一个强大的协调原语，它实现了对关键资源的互斥访问。

一种协调方法是为每个不同的协调需求开发服务。
例如，Amazon Simple Queue Service `[3]` 专门关注队列。
其他服务是专门为领导选举 `[25]` 和配置 `[27]` 开发的。
实现更强大原语的服务可用于实现功能较弱的原语。
例如，Chubby `[6]` 是一个具有强同步保证的锁定服务。
然后可以使用锁来实现领导者选举、组成员资格等。

在设计我们的协调服务时，我们不再在服务器端实现特定的原语，而是选择公开一个 API，使应用程序开发人员能够实现他们自己的原语。
这样的选择导致了协调内核的实现，该内核支持新的原语，而无需更改服务核心。
这种方法支持适应应用程序要求的多种形式的协调，而不是将开发人员限制在一组固定的原语中。

在设计我们的协调服务时，我们不再在服务器端实现特定的原语，而是选择公开一个 API，使应用程序开发人员能够实现他们自己的原语。
这样的选择导致了协调内核的实现，该内核支持新的原语，而无需更改服务核心。
这种方法支持适应应用程序要求的多种形式的协调，而不是将开发人员限制在一组固定的原语中。

在设计 ZooKeeper 的 API 时，我们远离了阻塞原语，例如锁。
协调服务的阻塞原语可能会导致慢速或故障客户端等问题，从而对更快客户端的性能产生负面影响。
如果处理请求依赖于其他客户端的响应和故障检测，则服务本身的实现会变得更加复杂。
因此，我们的系统 Zookeeper 实现了一个 API，该 API 可以操作简单的无等待数据对象，就像在文件系统中一样分层组织。
实际上，ZooKeeper API 类似于任何其他文件系统，仅从 API 签名来看，ZooKeeper 似乎是没有锁定方法、打开和关闭的 Chubby。
然而，实现免等待数据对象将 ZooKeeper 与基于阻塞原语(例如锁)的系统区分开来。

尽管无等待属性对于性能和容错很重要，但对于协调来说还不够。
我们还必须为运营提供订单保证。
特别是，我们发现保证所有操作的 FIFO 客户端排序和线性化写入可以有效实现服务，并且足以实现我们的应用程序感兴趣的协调原语。
事实上，我们可以使用我们的 API 为任意数量的进程实现共识，并且根据 Herlihy 的层次结构，ZooKeeper 实现了一个通用对象 `[14]`。

ZooKeeper 服务包含一组使用复制来实现高可用性和性能的服务器。
其高性能使包含大量进程的应用程序能够使用这样的协调内核来管理协调的所有方面。
我们能够使用简单的流水线架构来实现 ZooKeeper，该架构允许我们处理成百上千个未完成的请求，同时仍然实现低延迟。
这样的管道自然能够以 FIFO 顺序从单个客户端执行操作。
保证 FIFO 客户端顺序使客户端能够异步提交操作。
通过异步操作，客户端一次可以有多个未完成的操作。
例如，当新客户端成为领导者并且必须操作元数据并相应地更新它时，此功能是可取的。
没有多个未完成操作的可能性，初始化时间可以是秒级而不是亚秒级。

为了保证更新操作满足线性化，我们实现了一个基于领导者的原子广播协议 `[23]`，称为 Zab `[24]`。
然而，ZooKeeper 应用程序的典型工作负载由读取操作主导，因此需要扩展读取吞吐量。
在 ZooKeeper 中，服务器在本地处理读操作，我们不使用 Zab 对它们进行完全排序。

在客户端缓存数据是提高读取性能的一项重要技术。
例如，一个进程缓存当前领导者的标识符而不是每次需要知道领导者时探测 ZooKeeper 是有用的。
ZooKeeper 使用监视机制使客户端能够缓存数据，而无需直接管理客户端缓存。
通过这种机制，客户端可以监视给定数据对象的更新，并在更新时收到通知。
Chubby 直接管理客户端缓存。
它阻止更新以使所有缓存正在更改的数据的客户端的缓存无效。
在这种设计下，如果这些客户端中的任何一个运行缓慢或出现故障，更新就会延迟。
Chubby 使用租约来防止有故障的客户端无限期地阻塞系统。
然而，租约只能限制慢速或故障客户端的影响，而 ZooKeeper watches 则完全避免了这个问题

在本文中，我们将讨论 ZooKeeper 的设计和实现。
使用 ZooKeeper，我们能够实现应用程序所需的所有协调原语，即使只有写入是可线性化的。
为了验证我们的方法，我们展示了我们如何使用 ZooKeeper 实现一些协调原语。

总之，在本文中我们主要贡献有：

**协调内核**：
我们提出了一种在分布式系统中使用具有宽松一致性保证的无等待协调服务。
特别是，我们描述了协调内核的设计和实现，我们已在许多关键应用程序中使用它来实现各种协调技术。

**协调清单**：
我们展示了如何使用 ZooKeeper 来构建更高级别的协调原语，甚至是分布式应用程序中经常使用的阻塞和强一致性原语。

**协调经验**：
分享一些 ZooKeeper 的使用方法，并对其性能进行评估。

### 2 ZooKeeper 服务

客户端使用 ZooKeeper 库通过 API 向 ZooKeeper 提交请求。
除了通过 API 暴露 ZooKeeper 服务接口之外，客户端库还管理客户端和 ZooKeeper 服务器之间的网络连接。

在本节中，我们首先从架构来概览 ZooKeeper 服务。
然后我们讨论客户端用来与 ZooKeeper 交互的 API。

**术语**
在本文中，我们使用 client 表示 ZooKeeper 服务的用户，server 表示提供 ZooKeeper 服务的进程，znode 表示 ZooKeeper 数据中的内存数据节点，
它组织在一个分层的命名空间中，称作为数据树。
我们还使用术语更新和写入来指代任何修改数据树状态的操作。
客户端在连接到 ZooKeeper 并获取会话句柄时建立会话，并通过该句柄发出请求。

#### 2.1 服务概览

ZooKeeper 向其客户端提供一组数据节点 (znodes) 的抽象，根据分层名称空间进行组织。
此层次结构中的 znode 是客户端通过 ZooKeeper API 操作的数据对象。
分层命名空间通常用于文件系统。
这是一种组织数据对象的理想方式，因为用户习惯于这种抽象，并且它可以更好地组织应用程序元数据。
为了引用给定的 znode，我们对文件系统路径使用标准的 UNIX 表示法。
例如，我们使用 /A/B/C 来表示 znode C 的路径，其中 C 有 B 作为其父级，B 有 A 作为其父级。
所有 znode 都存储数据，所有 znode，除了临时 znode，都可以有子节点。

客户端可以创建两种类型的 znode：

**常规型(Regular)**：客户端通过显式创建和删除它们来操作常规 znode。
**临时型(Ephemeral)**：客户端创建这样的 znode，他们要么明确删除它们，要么让系统在创建它们的会话终止时自动删除它们(故意或由于故障)。

此外，在创建新的 znode 时，客户端可以设置一个顺序标志。
使用顺序标志集(sequential flag)创建的节点具有附加到其名称的单调递增计数器的值。
如果 n 是新的 znode 并且 p 是父节点，则 n 的序列值永远不会小于在 p 下创建的任何其他顺序 znode 的名称中的值。

ZooKeeper 实现了 watches 以允许客户端及时接收更改通知而无需轮询。
当客户端发出设置了监视标志的读取操作时，该操作将正常完成，除非服务器承诺在返回的信息发生更改时通知客户端。
watches 是与会话相关的一次性触发器；一旦触发或会话关闭，它们将被取消注册。
watches 指示发生了更改，但不提供更改。
例如，如果客户端在 “/foo” 更改两次之前发出 getData(“/foo”, true)，客户端将收到一个监视事件，告诉客户端 “/foo” 的数据已更改。
例如连接丢失事件一样的会话事件，也被发送到 watches 回调，以便客户端知道 watches 事件可能会有延迟。
