---
title: ZooKeeper Wait-free coordination for Internet-scale systems 中文翻译版
date: 2021-07-05 22:26:13
tags:
- "论文"
- "Zookeeper"
id: zookeeper_wait_free_coordination_for_internet-scale_systems
no_word_count: true
no_toc: false
categories: 大数据
---

## ZooKeeper: Wait-free coordination for Internet-scale systems 中文翻译版

作者：

Patrick Hunt、Mahadev Konar、Flavio P. Junqueira、Benjamin Reed

### 摘要

在本文中，我们描述了 ZooKeeper，一种用于协调分布式应用程序进程的服务。
由于 ZooKeeper 是关键基础设施的一部分，ZooKeeper 旨在提供一个简单且高性能的内核，用于在客户端构建更复杂的协调原语。
它在一个复制的、集中的服务中整合了来自群消息传递、共享寄存器和分布式锁服务的元素。
ZooKeeper 公开的接口具有共享寄存器的免等待特性，具有类似于分布式文件系统的缓存失效机制的事件驱动机制，以提供简单而强大的协调服务。

ZooKeeper 接口支持高性能服务实现。
除了无等待属性之外，ZooKeeper 还为每个客户端保证请求的 FIFO 执行和所有更改 ZooKeeper 状态的请求的线性化。
这些设计决策可以实现高性能处理管道并使本地服务器可以满足读取请求。
对于目标工作负载，2:1 到 100:1 的读写比率，ZooKeeper 每秒可以处理数万到数十万个事务。
这种性能允许客户端应用程序广泛使用 ZooKeeper。

### 1 引言

大规模分布式应用需要不同形式的协调服务。
配置是最基本的协调形式之一。
在最简单的形式中，配置只是系统进程的操作参数列表，而更复杂的系统具有动态配置参数。
组成员和领导者选举在分布式系统中也很常见：进程通常需要知道哪些其他进程还活着以及这些进程负责什么。
锁构成了一个强大的协调原语，它实现了对关键资源的互斥访问。

一种协调方法是为每个不同的协调需求开发服务。
例如，Amazon Simple Queue Service `[3]` 专门关注队列。
其他服务是专门为领导选举 `[25]` 和配置 `[27]` 开发的。
实现更强大原语的服务可用于实现功能较弱的原语。
例如，Chubby `[6]` 是一个具有强同步保证的锁定服务。
然后可以使用锁来实现领导者选举、组成员资格等。

在设计我们的协调服务时，我们不再在服务器端实现特定的原语，而是选择公开一个 API，使应用程序开发人员能够实现他们自己的原语。
这样的选择导致了协调内核的实现，该内核支持新的原语，而无需更改服务核心。
这种方法支持适应应用程序要求的多种形式的协调，而不是将开发人员限制在一组固定的原语中。

在设计我们的协调服务时，我们不再在服务器端实现特定的原语，而是选择公开一个 API，使应用程序开发人员能够实现他们自己的原语。
这样的选择导致了协调内核的实现，该内核支持新的原语，而无需更改服务核心。
这种方法支持适应应用程序要求的多种形式的协调，而不是将开发人员限制在一组固定的原语中。

在设计 ZooKeeper 的 API 时，我们远离了阻塞原语，例如锁。
协调服务的阻塞原语可能会导致慢速或故障客户端等问题，从而对更快客户端的性能产生负面影响。
如果处理请求依赖于其他客户端的响应和故障检测，则服务本身的实现会变得更加复杂。
因此，我们的系统 Zookeeper 实现了一个 API，该 API 可以操作简单的无等待数据对象，就像在文件系统中一样分层组织。
实际上，ZooKeeper API 类似于任何其他文件系统，仅从 API 签名来看，ZooKeeper 似乎是没有锁定方法、打开和关闭的 Chubby。
然而，实现免等待数据对象将 ZooKeeper 与基于阻塞原语(例如锁)的系统区分开来。

尽管无等待属性对于性能和容错很重要，但对于协调来说还不够。
我们还必须为运营提供订单保证。
特别是，我们发现保证所有操作的 FIFO 客户端排序和线性化写入可以有效实现服务，并且足以实现我们的应用程序感兴趣的协调原语。
事实上，我们可以使用我们的 API 为任意数量的进程实现共识，并且根据 Herlihy 的层次结构，ZooKeeper 实现了一个通用对象 `[14]`。

ZooKeeper 服务包含一组使用复制来实现高可用性和性能的服务器。
其高性能使包含大量进程的应用程序能够使用这样的协调内核来管理协调的所有方面。
我们能够使用简单的流水线架构来实现 ZooKeeper，该架构允许我们处理成百上千个未完成的请求，同时仍然实现低延迟。
这样的管道自然能够以 FIFO 顺序从单个客户端执行操作。
保证 FIFO 客户端顺序使客户端能够异步提交操作。
通过异步操作，客户端一次可以有多个未完成的操作。
例如，当新客户端成为领导者并且必须操作元数据并相应地更新它时，此功能是可取的。
没有多个未完成操作的可能性，初始化时间可以是秒级而不是亚秒级。

为了保证更新操作满足线性化，我们实现了一个基于领导者的原子广播协议 `[23]`，称为 Zab `[24]`。
然而，ZooKeeper 应用程序的典型工作负载由读取操作主导，因此需要扩展读取吞吐量。
在 ZooKeeper 中，服务器在本地处理读操作，我们不使用 Zab 对它们进行完全排序。

在客户端缓存数据是提高读取性能的一项重要技术。
例如，一个进程缓存当前领导者的标识符而不是每次需要知道领导者时探测 ZooKeeper 是有用的。
ZooKeeper 使用监视机制使客户端能够缓存数据，而无需直接管理客户端缓存。
通过这种机制，客户端可以监视给定数据对象的更新，并在更新时收到通知。
Chubby 直接管理客户端缓存。
它阻止更新以使所有缓存正在更改的数据的客户端的缓存无效。
在这种设计下，如果这些客户端中的任何一个运行缓慢或出现故障，更新就会延迟。
Chubby 使用租约来防止有故障的客户端无限期地阻塞系统。
然而，租约只能限制慢速或故障客户端的影响，而 ZooKeeper watches 则完全避免了这个问题

在本文中，我们将讨论 ZooKeeper 的设计和实现。
使用 ZooKeeper，我们能够实现应用程序所需的所有协调原语，即使只有写入是可线性化的。
为了验证我们的方法，我们展示了我们如何使用 ZooKeeper 实现一些协调原语。

总之，在本文中我们主要贡献有：

**协调内核**：
我们提出了一种在分布式系统中使用具有宽松一致性保证的无等待协调服务。
特别是，我们描述了协调内核的设计和实现，我们已在许多关键应用程序中使用它来实现各种协调技术。

**协调清单**：
我们展示了如何使用 ZooKeeper 来构建更高级别的协调原语，甚至是分布式应用程序中经常使用的阻塞和强一致性原语。

**协调经验**：
分享一些 ZooKeeper 的使用方法，并对其性能进行评估。

### 2 ZooKeeper 服务

客户端使用 ZooKeeper 库通过 API 向 ZooKeeper 提交请求。
除了通过 API 暴露 ZooKeeper 服务接口之外，客户端库还管理客户端和 ZooKeeper 服务器之间的网络连接。

在本节中，我们首先从架构来概览 ZooKeeper 服务。
然后我们讨论客户端用来与 ZooKeeper 交互的 API。

**术语**
在本文中，我们使用 client 表示 ZooKeeper 服务的用户，server 表示提供 ZooKeeper 服务的进程，znode 表示 ZooKeeper 数据中的内存数据节点，
它组织在一个分层的命名空间中，称作为数据树。
我们还使用术语更新和写入来指代任何修改数据树状态的操作。
客户端在连接到 ZooKeeper 并获取会话句柄时建立会话，并通过该句柄发出请求。

#### 2.1 服务概览

ZooKeeper 向其客户端提供一组数据节点 (znodes) 的抽象，根据分层名称空间进行组织。
此层次结构中的 znode 是客户端通过 ZooKeeper API 操作的数据对象。
分层命名空间通常用于文件系统。
这是一种组织数据对象的理想方式，因为用户习惯于这种抽象，并且它可以更好地组织应用程序元数据。
为了引用给定的 znode，我们对文件系统路径使用标准的 UNIX 表示法。
例如，我们使用 /A/B/C 来表示 znode C 的路径，其中 C 有 B 作为其父级，B 有 A 作为其父级。
所有 znode 都存储数据，所有 znode，除了临时 znode，都可以有子节点。

客户端可以创建两种类型的 znode：

**常规型(Regular)**：客户端通过显式创建和删除它们来操作常规 znode。
**临时型(Ephemeral)**：客户端创建这样的 znode，他们要么明确删除它们，要么让系统在创建它们的会话终止时自动删除它们(故意或由于故障)。

此外，在创建新的 znode 时，客户端可以设置一个顺序标志。
使用顺序标志集(sequential flag)创建的节点具有附加到其名称的单调递增计数器的值。
如果 n 是新的 znode 并且 p 是父节点，则 n 的序列值永远不会小于在 p 下创建的任何其他顺序 znode 的名称中的值。

ZooKeeper 实现了 watches 以允许客户端及时接收更改通知而无需轮询。
当客户端发出设置了监视标志的读取操作时，该操作将正常完成，除非服务器承诺在返回的信息发生更改时通知客户端。
watches 是与会话相关的一次性触发器；一旦触发或会话关闭，它们将被取消注册。
watches 指示发生了更改，但不提供更改。
例如，如果客户端在 “/foo” 更改两次之前发出 getData(“/foo”, true)，客户端将收到一个监视事件，告诉客户端 “/foo” 的数据已更改。
例如连接丢失事件一样的会话事件，也被发送到 watches 回调，以便客户端知道 watches 事件可能会有延迟。

**数据模型**
ZooKeeper 的数据模型本质上是一个 API 简化的文件系统，只有完整的数据读写，或者是一个具有层次化的键/值表。
分层命名空间对于为不同应用程序的命名空间分配子树以及设置对这些子树的访问权限非常有用。
我们还利用客户端目录的概念来构建更高级别的原语，我们将在 2.4 节中看到。

![图 1：ZooKeeper 分层名称空间的图示](https://i.loli.net/2021/07/06/vTYRiDhJajWxSmn.png)

与文件系统中的文件不同，znode 不是为一般数据存储而设计的。
相反，znode 映射到客户端应用程序的抽象，通常对应于用于协调目的的元数据。
为了说明这一点，在图 1 中，我们有两个子树，一个用于应用程序 1 (/app1)，另一个用于应用程序 2 (/app2)。
应用程序 1 的子树实现了一个简单的组成员协议：每个客户端进程 p_i 在 /app1 下创建一个 znode pi，只要进程正在运行，它就会一直存在。

尽管 znodes 不是为一般数据存储而设计的，但 ZooKeeper 确实允许客户端存储一些可用于分布式计算中的元数据或配置的信息。
例如，在基于领导者的应用程序中，这对于刚刚开始了解哪个其他服务器当前是领导者的应用程序服务器很有用。
为了实现这个目标，我们可以让当前的领导者将这些信息写在 znode 空间中的一个已知位置。
znode 还具有与时间戳和版本计数器相关联的元数据，这允许客户端跟踪对 znode 的更改并根据 znode 的版本执行条件更新。

**会话**
客户端连接到 ZooKeeper 并发起会话。
会话在到达配置的事件后会超时。
如果 ZooKeeper 在超过该超时时间而没有从其会话中收到任何内容，则认为客户端有故障。
当客户端明确关闭会话 handle 或 ZooKeeper 检测到客户端故障时，会话关闭。
在会话中，客户端观察反映其操作执行的一系列状态变化。
会话使客户端能透明地在 ZooKeeper 集合内从一台服务器移动到另一台服务器，而不中断服务。

#### 2.2 客户端 API

我们在下面介绍 ZooKeeper API 的一个相关子集，并讨论每个请求的语义。

**create(path, data, flags)**：
创建一个 znode 将其路径名设置为 path 并存储 data[] 数据，然后返回新 znode 的名称。
flags 标识能让客户端选择 znode 的类型，具体是常规型还是临时型。

**delete(path, version)**：
如果 znode 处于预期版本，则删除 znode 路径。

**exists(path, watch)**：
如果具有路径名 path 的 znode 存在，则返回 true，否则返回 false。
watch 标志使客户端能够在 znode 上设置监视。

**getData(path, watch)**：
返回与 znode 关联的数据和元数据，例如版本信息。
watch 标志的工作方式与它对exists() 的工作方式相同，除了如果znode 不存在ZooKeeper 不会设置监视。

**setData(path, data, version)**：
如果版本号是 znode 的当前版本，则将 data[] 写入 znode 路径。

**getChildren(path, watch)**：
返回 znode 子节点的名称集。

**sync(path)**:
等待所有挂起的更新操作开始传播向客户端所连接的服务器。
该路径当前被忽略。

> 注：即等待所有待完成的更新操作完成更新，但是忽略输入路径。

所有方法都在 API 中提供了同步和异步版本。
应用程序在需要执行单个 ZooKeeper 操作并且没有并发任务要执行时使用同步 API，因此它会进行必要的 ZooKeeper 调用并阻塞。
然而，异步 API 使应用程序能够同时执行多个未完成的 ZooKeeper 操作和其他任务。
ZooKeeper 客户端保证按顺序调用每个操作的相应回调。

值得注意的是，ZooKeeper 不使用 handle 来访问 znode。
每个请求都包含正在操作的 znode 的完整路径。
这种选择不仅简化了 API(没有 open() 或 close() 方法)，而且还消除了服务器需要维护的额外状态。

每个更新方法都采用一个预期的版本号，这使得有条件更新的实现成为可能。
如果 znode 的实际版本号与预期版本号不匹配，则更新失败并出现意外版本错误。
如果版本号为 -1，则不执行版本检查。

#### 2.3 ZooKeeper 保证

ZooKeeper 有两个基本的排序保证：

**可线性写入**：
所有更新 ZooKeeper 状态的请求都是可序列化的并尊重优先级。

**先进先出的客户端顺序**：
来自给定客户端的所有请求都按照客户端发送的顺序执行。

请注意，我们对线性化的定义与 Herlihy `[15]` 最初提出的定义不同，我们称之为 A-线性化(异步线性化)。
在 Herlihy 对线性化的最初定义中，一个客户端一次只能有一个未完成的操作(一个客户端是一个线程)。
在我们的情况下，我们允许一个客户端有多个未完成的操作，因此我们可以选择让同一客户端的未完成操作无须的或按照 FIFO 顺序执行。
为了符合设计需求我们选择了后者。
重要的是要观察到所有适用于可线性化对象的结果也适用于 A 可线性化对象，因为满足 A-线性化的系统也同时满足了线性化。
因为只有更新请求是 A-线性化，所以 ZooKeeper 在每个副本本地处理读取请求。
这允许服务随着服务器添加到系统而线性的进行扩张。

要了解这两种保证如何相互作用，请考虑以下场景。
由多个进程组成的系统会选举一个领导者来指挥工作进程。
当新的领导者接管系统时，它必须更改大量配置参数并在完成后通知其他进程。
然后我们有两个重要的要求：

- 当新的领导开始修改内容时，我们不希望其它的进程使用正在修改的配置。
- 如果新的领导者在配置完全更新之前死亡，我们不希望其它进程使用这个部分配置。

请注意，分布式锁(例如 Chubby 提供的锁)将有助于满足第一个要求，但不足以满足第二个要求。
有了 ZooKeeper，新的领导者可以指定一条路径作为 ready znode；其他进程只会在该 znode 存在时使用该配置。
新的 leader 通过删除 ready、更新各种配置znode、重新创建 ready 来改变配置。
所有这些变动都可以通过管道进行异步发布，以快速更新配置状态。
尽管更改操作的延迟在 2 毫秒的数量级，但如果请求一个接一个地发出，更新 5000 个不同 znode 的新领导者将花费 10 秒；
如果通过异步发出请求，则可以在 1 秒钟之内完成。
由于顺序保证，如果一个进程看到 ready znode，它也必须看到新领导者所做的所有配置更改。
如果在创建 ready znode 之前新领导者死亡，则其他进程知道配置尚未最终确定并且不会使用它。

上述方案仍然有一个问题：如果一个进程在新的领导者开始进行更改之前看到 ready znode 存在，然后在更改正在进行时开始读取配置会发生什么。
这个问题是通过通知的顺序保证来解决的：如果客户端正在观察更改，客户端将在看到更改后系统的新状态之前看到通知事件。
因此，如果读取 ready znode 的进程请求收到有关该 znode 更改的通知，它将在读取任何新配置之前看到客户端更改的通知。

当客户端除了 ZooKeeper 之外还有自己的通信通道时，会出现另一个问题。
例如，考虑两个客户端 A 和 B，它们在 ZooKeeper 中具有共享配置并通过共享通信通道进行通信。
如果 A 更改 ZooKeeper 中的共享配置并通过共享通信通道告诉 B 更改，B 将期望在重新读取配置时看到更改。
如果 B 的 ZooKeeper 副本稍微落后于 A，则它可能看不到新配置。
使用上述保证 B 可以通过在重新读取配置之前发出写入来确保它看到最新的信息。

为了更有效地处理这种情况，ZooKeeper 提供了 sync 请求：跟随进行读取的操作被称为慢读。
sync 使得服务器先完成读取请求然后再完成所有等待的写入请求而没有产生完全写入的开销。
这个原语在思想上类似于 ISIS `[5]` 的 flush 。

ZooKeeper 还具有以下两个活动性和持久性保证：
如果大多数 ZooKeeper 服务器处于活动状态则通信服务将可用；
如果 ZooKeeper 服务成功响应更改请求，则只要仲裁服务器最终能够恢复，该更改就会在任何数量节点的故障中正常恢复。

#### 2.4 原语的例子

在本节中，我们将展示如何使用 ZooKeeper API 来实现更强大的原语。
ZooKeeper 服务对这些更强大的原语一无所知，因为它们完全在客户端使用 ZooKeeper 客户端 API 实现。
一些常见的原语，如组成员资格和配置管理，也是免等待的。
对于其他的，比如集合点，客户端需要等待一个事件。
即使 ZooKeeper 是无等待的，我们也可以使用 ZooKeeper 实现高效的阻塞原语。
ZooKeeper 的排序保证允许对系统状态进行有效推理，而 watches 则允许有效等待。

**配置管理**
ZooKeeper 可用于在分布式应用程序中实现动态配置管理。
配置以最简单的形式存储在 znode Z<sub>c</sub> 中。
进程以 Z<sub>c</sub> 的完整路径名启动。
启动进程通过读取 zc 并将 watch 标志设置为 true 来获取它们的配置。
如果 zc 中的配置被更新，进程会收到通知并读取新配置，再次将 watch 标志设置为 true。

请注意，在此方案中，与大多数其他使用 watch 的方案一样，确保进程具有最新信息。
例如，如果一个正在观察 Z<sub>c</sub> 的进程收到 Z<sub>c</sub> 更改的通知，并且在它可以为 Z<sub>c</sub> 发出读取之前，
还有三个 Z<sub>c</sub> 更改，则该进程不会收到另外三个通知事件。
这不会影响进程的行为，因为这三个事件只会通知进程它已经知道的事情：它拥有的关于 Z<sub>c</sub> 的信息是陈旧的。

**集合**
有时在分布式系统中，最终系统配置的外观并不总是先验清楚的。
客户端可能想要启动一个主进程和几个工作进程，但是启动进程是由调度程序完成的，因此客户端不知道它可以给工作进程连接到主进程的地址和端口等信息。
我们通过 ZooKeeper 使用客户端创建的集合点 znode Z<sub>r</sub> 来处理这种情况。
客户端将 Z<sub>r</sub> 的完整路径名作为主进程和工作进程的启动参数进行传递。
当主进程启动时，它会在 Z<sub>r</sub> 中填入有关它正在使用的地址和端口的信息。
当工作进程启动时，它会在 watch 设置为 true 的情况下读取 Z<sub>r</sub> 。
如果 Z<sub>r</sub> 尚未填写，则工作进程会等待 Z<sub>r</sub> 更新时收到通知。
如果 Z<sub>r</sub> 是一个临时节点，主进程和工作进程可以监视 Z<sub>r</sub> 的删除并在客户端结束时清理自己。

**组关系**
我们利用临时节点来实现组成员身份。
具体来说，我们使用临时节点允许我们查看创建节点的会话状态这一事实。
我们首先指定一个 znode Z<sub>g</sub> 来表示该组。
当组的进程成员启动时，它会在 Z<sub>g</sub> 下创建一个临时子 znode。
如果每个进程都有唯一的名称或标识符，则该名称将用作子 znode 的名称；否则，该进程会使用 SEQUENTIAL 标志创建 znode 以获得唯一的名称分配。
例如，进程可以将进程信息放入子 znode 的数据中，例如进程使用的地址和端口。

在 Z<sub>g</sub> 下创建子 znode 后，进程正常启动。
它不需要做任何其他事情。
如果进程失败或结束，在 Z<sub>g</sub> 下代表它的 znode 将被自动删除。

进程可以通过简单地列出 Z<sub>g</sub> 的子进程来获取组信息。
如果进程想要监视组成员身份的更改，则该进程可以将监视标志设置为 true 并在收到更改通知时刷新组信息(始终将监视标志设置为 true)。

**简单的锁**
ZooKeeper 虽然不是锁服务，但是可以用来实现锁。
使用 ZooKeeper 的应用程序通常使用根据其需要定制的同步原语，如上所示。
这里我们展示了如何使用 ZooKeeper 实现锁，以表明它可以实现多种通用同步原语。

最简单的锁实现使用 “锁文件”。
锁由一个 znode 表示。
为了获取锁，客户端尝试使用 EPHEMERAL 标志创建指定的 znode。
如果创建成功，客户端持有锁。
否则，如果当前领导者死亡，客户端可以读取设置了监视标志的 znode 以得到通知。
客户端在死亡或显式删除 znode 时释放锁。
等待锁的其他客户端一旦观察到 znode 被删除，就会再次尝试获取锁。

虽然这个简单的锁定协议有效，但它确实存在一些问题。
首先，它受到羊群效应(herd effect)的影响。
如果有很多客户端在等待获取锁，即使只有一个客户端可以获取锁，他们也会在锁被释放时争夺锁。
其次，它只实现了排他锁。
以下两个原语展示如何克服这两个问题。

**解决羊群效应简单锁**
我们定义了一个锁 znode l 来实现这样的锁。
直观地，我们将所有请求锁定的客户端排列起来，每个客户端按照请求到达的顺序获得锁定。

**加锁**

```text
n = create(l+“/lock-”, EPHEMERAL|SEQUENTIAL)
C = getChildren(l, false)
if n is lowest znode in C, exit
p = znode in C ordered just before n
if exists(p, true) wait for watch event
goto 2
```

**解锁**

```text
delete(n)
```

在 Lock 部分的第 1 行中使用 SEQUENTIAL 标志命令使应用程序按顺序申请锁。
如果客户端的 znode 在第 3 行具有最低的序列号，则客户端持有锁。
否则，客户端会等待加锁程序删除 znode 或者从持有锁的客户端获得锁。
通过观测客户端 znode 之前获得锁的 znode，我们避免了羊群效应，当锁被释放或锁请求被放弃时，我们只唤醒一个进程。
一旦客户端正在监视的 znode 消失，客户端必须检查它现在是否持有锁。
(之前的锁请求可能已经被放弃，并且有一个序列号较低的 znode 仍在等待或持有锁。)

释放锁就像删除代表锁请求的 znode n 一样简单。
通过在创建时使用 EPHEMERAL 标志，崩溃的进程将自动清除任何锁请求或释放它们可能拥有的任何锁。

综上所述，这种加锁方案有以下优点：

1. 删除一个 znode 只会导致一个客户端唤醒，因为每个 znode 正好被另一个客户端监视，所以我们不会受羊群效应影响。
2. 没有轮询或超时。
3. 由于我们实现了锁的方式，我们可以通过浏览 ZooKeeper 的数据看到锁争用的数量，断锁，以及调试锁。

**读/写锁**
为了实现读/写锁，我们稍微改变了锁程序，并有单独的读锁和写锁程序。
解锁过程与全局锁定情况相同。

**写锁**

```text
n = create(l+“/write-”, EPHEMERAL|SEQUENTIAL)
C = getChildren(l, false)
if n is lowest znode in C, exit
p = znode in C ordered just before n
if exists(p, true) wait for event
goto 2
```

**读锁**

```text
n = create(l+“/read-”, EPHEMERAL|SEQUENTIAL)
C = getChildren(l, false)
if no write znodes lower than n in C, exit
p = write znode in C ordered just before n
if exists(p, true) wait for event
goto 3
```

此锁定过程与以前的锁定略有不同。
写锁仅在命名上有所不同。
由于读锁可能是共享的，第 3 行和第 4 行略有不同，因为只有较早的写锁 znode 会阻止客户端获取读锁。
当有多个客户端等待读锁并在删除具有较低序列号的“写” znode 时得到通知，我们可能会遇到“羊群效应”；
事实上，这是一种理想的行为，所有这些读取客户端都应该被释放，因为它们现在可能拥有锁。

**双重屏障**
双屏障使客户端能够同步计算的开始和结束。
当由屏障阈值定义的足够进程加入屏障时，进程开始运行计算并在完成后离开屏障。
我们用 znode 表示 ZooKeeper 中的屏障，称为 b。
每个进程 p 在进入屏障时都向 b 注册(通过创建一个 znode 作为 b 的子节点)，在运算结束后进行注销(删除对应子节点)。
当 b 的子节点数超过屏障阈值时，进程可以进入屏障。
当所有进程都删除了它们的子进程时，进程可以离开屏障。
我们使用 watche 来有效地等待进入和退出条件得到满足。
在注册过程中，进程会观察 b 的就绪子进程的数量，然后进程会创建子进程导致子进程数量超过阈值。
在注销过程中，进程会观察运行完成的子进程，并且仅在该 znode 被删除后才检查退出条件。

### 3 ZooKeeper 应用程序

我们现在描述一些使用 ZooKeeper 的应用程序，并简要解释他们如何使用它。
我们以粗体显示每个示例的原语。

**获取服务**
数据爬取是搜索引擎的重要组成部分，而雅虎抓取了数十亿个 Web 文档。
获取服务(FS) 是雅虎爬取系统其中的一个服务。
本质上，它具有控制页面获取进程的主进程。
master 为 fetchers 提供配置，fetchers 写回通知他们的状态和健康状况。
使用 ZooKeeper for FS 的主要优点是从 master 的故障中恢复，即使出现故障也能保证可用性，以及将客户端与服务器解耦，
允许它们通过从 ZooKeeper 读取它们的状态来将它们的请求定向到健康的服务器。
因此，FS 主要使用 ZooKeeper 来管理 **配置元数据(configuration metadata)**，尽管它也使用 ZooKeeper 来选举 master
(**领导选举(leader election)**)。

![图 2：带有 Fetching Service 的一台 ZK 服务器的工作负载](https://i.loli.net/2021/07/08/WzA7GjkYdLFJ5Zw.png)

> 注：每个点代表一个一秒的样本。

图 2 显示了 FS 使用的 ZooKeeper 服务器在三天内的读写流量。
为了生成这个图，我们计算了该时间段内每秒的操作次数，每个点对应于该秒的操作次数。
我们观察到，与写入流量相比，读取流量要高得多。
在速率高于每秒 1000 次操作的期间，读写比率在 10:1 和 100:1 之间变化。
此工作负载中的读取操作是 `getData()`、`getChildren()` 和 `exists()`，按流行程度递增。

**Katta**
Katta `[17]` 是一个使用 ZooKeeper 进行协调的分布式索引器，它不是雅虎公司的应用。
Katta 使用分片来划分索引工作。
主服务器将分片分配给从服务器并跟踪进度。
主服务器也可能发生故障，因此其他服务器必须准备好在发生故障时接管。
Katta 使用 ZooKeeper 跟踪从服务器和主服务器(组成员身份)的状态，并处理主故障转移(领导选举)。
Katta 还使用 ZooKeeper 来跟踪和传播分片到从属设备的分配(配置管理)。

**雅虎消息广播**
雅虎消息广播服务(YMB)是一个分布式发布订阅系统。
系统管理数以千计的主题，客户端可以向这些主题发布消息和接收消息。
主题分布在一组服务器中以提供可伸缩性。
每个主题都使用主备份方案进行复制，以确保将消息复制到两台机器以确保可靠的消息传递。
组成 YMB 的服务器使用无共享分布式架构，这使得协调对于正确操作至关重要。
YMB 使用 ZooKeeper 管理主题的分发(**配置元数据(configuration metadata)**)，
处理系统中机器的故障(**故障检测和组成员身份(failure detection, group membership)**)，并控制系统运行。

![图 3：雅虎的布局 ZooKeeper 中的消息代理 (YMB) 结构](https://i.loli.net/2021/07/08/WuIyZ92rGzoCYDP.png)

图 3 显示了 YMB 的部分 znode 数据结构。
每个代理域都有一个称为节点的 znode，组成 YMB 服务的每个活动服务器都有一个临时 znode。
每个 YMB 服务器在节点下创建一个临时 znode，其负载和状态信息通过 ZooKeeper 提供组成员身份和状态信息。
禁止关闭和迁移等节点由构成该服务的所有服务器进行监控，并允许对 YMB 进行集中控制。
对于 YMB 管理的每个主题，主题目录都有一个子 znode。
这些主题 znode 具有子 znode，它们指示每个主题的主服务器和备份服务器以及该主题的订阅者。
主服务器和备用服务器 znode 不仅允许服务器发现负责主题的服务器，而且它们还管理 **领导者选举(leader election)** 和处理服务器崩溃。

### 4 ZooKeeper 实现

![图 4：ZooKeeper 服务的组件](https://i.loli.net/2021/07/08/vzDamYM6cy4w8kK.png)

ZooKeeper 通过在组成服务的每个服务器上复制 ZooKeeper 数据来提供高可用性。
我们假设服务器因崩溃而失败，并且此类故障服务器稍后可能会恢复。
图 4 显示了 ZooKeeper 服务的高级组件。
收到请求后，服务器准备执行(请求处理器)。
如果这样的请求需要服务器之间的协调(写请求)，那么它们使用协议协议(原子广播的实现)，最后服务器提交对 ZooKeeper 数据库的更改，
并在集合的所有服务器之间完全复制。
在读取请求的情况下，快速读取本地数据库的状态并生成对请求的响应。

复制数据库是包含整个数据树的内存数据库。
树中的每个 znode 默认存储最大 1MB 的数据，但是这个最大值是一个配置参数，可以在具体案例。
为了可恢复性，我们有效地将更新记录到磁盘，并在将写入应用到内存数据库之前强制写入磁盘介质。
事实上，作为 Chubby `[8]`，我们保留已提交操作的重放日志(在我们的例子中是预写日志)并生成内存数据库的定期快照。

每个 ZooKeeper 服务器都为客户端提供服务。
客户端仅连接到一台服务器以提交其请求。
如前所述，读取请求由每个服务器数据库的本地副本提供服务。
改变服务状态的请求，写请求，由协议协议处理。

作为协议协议的一部分，写请求被转发到单个服务器，称为 leader1。
其余的 ZooKeeper 服务器，称为追随者，从领导者接收由状态变化组成的消息提议，并就状态变化达成一致。

#### 4.1 请求处理器

由于消息传递层是原子的，我们保证本地副本永远不会发散，尽管在任何时间点某些服务器可能比其他服务器应用了更多的事务。
与客户端发送的请求不同，事务是幂等的。
当 leader 收到写入请求时，它会计算应用写入时系统的状态，并将其转换为捕获此新状态的事务。
必须计算未来状态，因为可能存在尚未应用到数据库的未完成事务。
例如，如果客户端执行条件 setData 并且请求中的版本号与正在更新的 znode 的未来版本号匹配，则服务生成一个 setDataTXN，其中包含新数据、新版本号和更新的时间戳。
如果出现错误，例如版本号不匹配或要更新的 znode 不存在，则生成一个 errorTXN。
