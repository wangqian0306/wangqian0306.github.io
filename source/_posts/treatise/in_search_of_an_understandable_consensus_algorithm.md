---
title: In Search of an Understandable Consensus Algorithm 中文翻译
date: 2021-06-24 22:26:13
tags:
- "论文"
- "Raft"
id: in_search_of_an_understandable_consensus_algorithm
no_word_count: true
no_toc: false
categories: 大数据
---

## In Search of an Understandable Consensus Algorithm 中文翻译

作者：Diego Ongaro and John Ousterhout, Stanford University

[英文原文](https://www.usenix.org/system/files/conference/atc14/atc14-paper-ongaro.pdf)

### 引言

Raft 是一种用于管理复制日志的共识算法。
它产生的结果等价于 (multi-)Paxos，和 Paxos 一样高效，但它的结构设计与 Paxos 不同；这使得 Raft 更易于理解，也为构建实用系统提供了更好的基础。
为了增强可理解性，Raft 将共识的关键要素(例如领导节点选举、日志复制和安全性)进行分离，并强制执行更强的一致性以减少必须判断的状态数量。
用户研究的结果表明，Raft 比 Paxos 更容易让学生学习。
Raft 还包括一种用于更改集群成员的新机制，该机制使用重叠多数来保证安全。

### 1 简介 

共识算法允许一组机器作为一个连贯的组进行工作，可以在其某些成员的失效的情况下继续工作。
因此，它们在构建可靠的大型软件系统方面发挥着关键作用。
Paxos `[13, 14]` 在过去十年中主导了共识算法的讨论：大多数共识的实现都是基于 Paxos 或受其影响，而 Paxos 已成为用于教授学生共识的主要工具。

不幸的是，Paxos 非常难以理解，尽管作者多次尝试使其更易于理解。
此外，其架构需要进行复杂的更改才能支持实际系统。
这样做结果是使的系统构建者和学生都在为 Paxos 苦苦挣扎。

在自己研读 Paxos 之后，我们着手寻找一种新的共识算法，可以为系统构建和教育提供更好的基石。
我们的方法非常独特，因为我们的主要目标是可理解性：我们能否为实际系统定义一个共识算法，并以比 Paxos 更容易学习的方式来描述它？
此外，我们希望该算法能够促进对系统构建者至关重要的直觉的成长。
重要的不仅是算法要起作用，而且要清楚它为什么起作用。

这项工作的结果是一种称为 Raft 的共识算法。
在设计 Raft 时，我们应用了特定的技术来提高可理解性，包括分解(Raft 将领导选举、日志复制和安全性分开)和状态空间缩减
(相对于 Paxos，Raft 降低了不确定性的程度以及服务器之间可能不一致的方式)。
对两所大学的 43 名学生进行的用户研究表明，Raft 比 Paxos 更容易理解：
在学习了这两种算法后，其中 33 名学生能够比关于 Paxos 的问题更好地回答有关 Raft 的问题。

Raft 在许多方面类似于现有的共识算法(最值得注意的是，Oki 和 Liskov 的 Viewstamped Replication `[27, 20]`)，但它有几个新颖的特点：

- **强领导**：Raft 使用比其他共识算法更强大的领导形式。例如，日志条目仅从领导节点流向其他服务器。这简化了复制日志的管理，让 Raft 更容易理解。
- **领导选举**：Raft 使用随机计时器来选举领导节点。这仅为任何共识算法已经需要的心跳增加了少量机制，同时简单快速地解决了冲突。
- **成员变更**：Raft 用于更改集群中服务器集的机制使用了一种新的联合共识方法，其中两种不同配置的大多数在转换期间重叠。这允许集群在配置更改期间继续正常运行。

我们相信 Raft 优于 Paxos 和其他共识算法，无论是出于教育目的还是作为实现的基础。
它比其他算法更简单易懂；描述完整，足以满足实际系统的需要；它有几个开源实现，被多家公司使用；其安全特性已得到正式规定和证明；其效率可与其他算法相媲美。

论文的其余部分介绍了复制状态机问题(第 2 节)，讨论了 Paxos 的优缺点(第 3 节)，描述了我们实现可理解性的一般方法(第 4 节)，
介绍了 Raft 共识算法(第 5-7 节)，评估 Raft 性能(第 8 节)，并讨论相关工作(第 9 节)。

### 2 复制状态机

共识算法通常出现在复制状态机的背景下 `[33]`。
在这种方法中，一组服务器上的状态机计算相同状态的相同副本，并且即使某些服务器关闭也可以继续运行。
复制状态机用于解决分布式系统中的各种容错问题。
例如，具有单个集群领导节点的大型系统，如 GFS `[7]`、HDFS `[34]` 和 RAMCloud `[30]`
通常使用单独的复制状态机来管理领导节点选举并存储必须生存的配置信息防止领导崩溃。
复制状态机的例子包括 Chubby `[2]` 和 ZooKeeper `[9]`。

![图 1：复制状态机架构](https://i.loli.net/2021/08/05/V8k2rEI1zJdPiLB.png)

> 注：共识算法管理包含来自客户端的状态机命令的复制日志。状态机处理来自日志的相同命令序列，因此它们产生相同的输出。

复制状态机通常使用复制日志来实现，如图 1 所示。
每个服务器存储一个包含一系列命令的日志，它的状态机按顺序执行这些命令。
每个日志以相同的顺序包含相同的命令，因此每个状态机处理相同的命令序列。
由于状态机是确定性的，每个状态机都计算相同的状态和相同的输出序列。

保持复制日志的一致性是一致性算法的工作。
服务器上的共识模块接收来自客户端的命令并将它们添加到其日志中。
它与其他服务器上的共识模块通信，以确保每个日志最终包含相同顺序的相同请求，即使某些服务器出现故障。
一旦命令被正确复制，每个服务器的状态机就会按日志顺序处理它们，并将输出返回给客户端。
结果，服务器似乎形成了一个单一的、高度可靠的状态机。

实际系统的共识算法通常具有以下特性：

- 它们在所有非拜占庭(non-Byzantine)条件下确保安全(从不返回错误结果)，包括网络延迟、分区和丢包、重复和重新排序。
- 只要任何大多数服务器都可以运行并且可以相互通信以及与客户端通信，它们就具有完整的功能(可用)。因此，一个典型的五台服务器集群可以容忍任意两台服务器的故障。假设服务器因停止而失效：他们稍后可能会从稳定存储的状态中恢复并重新加入集群。
- 它们不依赖于时间来确保日志的一致性：错误的时钟和极端的消息延迟在最坏的情况下会导致可用性问题。
- 在一般情况下，只要集群的大部分响应了一轮远程过程调用，命令就可以完成；少数慢速服务器不会影响整体系统性能。

### 3 Paxos 有什么问题？

在过去的十年中，Leslie Lamport 的 Paxos 协议 `[13]` 几乎成为共识的同义词：它是课程中最常教授的协议，大多数共识的实现都以它为起点。
Paxos 首先定义了一个能够就单个决策达成一致的协议，例如单个复制的日志条目。
我们将这个子集称为单法令 Paxos。
Paxos 然后将这个协议的多个实例组合起来，以促进一系列决策，例如日志(multi-Paxos)。
Paxos 确保安全性和生命监测，并且支持集群成员的更改。
其正确性已被证明，在正常情况下是有效的。

不幸的是，Paxos 有两个明显的缺点。
第一个缺点是 Paxos 异常难以理解。

众所周知，完整的解释 `[13]` 是不透明的。很少有人能够成功地理解它，而且只有付出巨大的努力的情况下才有可能。
因此，有几次尝试用更简单的术语来解释 Paxos `[14, 18, 19]`。
这些解释侧重于单法令子集，但它们仍然具有挑战性。
在 NSDI 2012 对与会者的非正式调查中，我们发现很少有人对 Paxos 感到满意，即使是经验丰富的研究人员也是如此。
我们自己也在与 Paxos 斗争；直到阅读了几个简化的解释并设计了我们自己的替代方案之后，我们才能够理解完整的方案，这个过程花了将近一年的时间。

我们假设 Paxos 的不透明性源于它选择单法令子集作为其基础。
单法令 Paxos 密集而微妙：它分为两个阶段，没有简单直观的解释，不能独立理解。
因此，很难对单法令协议的工作原理产生直觉。
multi-Paxos 的组合规则显着增加了复杂性和微妙性。
我们认为，就多个决策(即日志而不是单个条目)达成共识的整体问题可以用其他更直接、更明显的方式进行分解。

Paxos 的第二个问题是它没有为构建实际实现提供良好的基础。
原因之一是对于 multi-Paxos 没有广泛认可的算法。
Lamport 的描述主要是关于单法令 Paxos；他勾画了多 Paxos 的可能方法，但缺少许多细节。
已经有几次尝试充实和优化 Paxos，例如 `[24]、[35] 和 [11]`，但这些尝试彼此不同，也与 Lamport 的初始设计不同。
Chubby `[4]` 等系统已经实现了类似 Paxos 的算法，但在大多数情况下，它们的细节尚未公开。

此外，Paxos 架构对于构建实用系统来说是一种糟糕的架构；这是单法令分解的另一个结果。
例如，独立选择一组日志条目，然后将它们融合到一个顺序日志中几乎没有什么好处；这只会增加复杂性。
围绕日志设计一个系统会更简单、更有效，其中新条目以受约束的顺序进行追加。
另一个问题是 Paxos 在其核心使用对称的点对点方法(尽管它最终暗示了一种弱领导形式作为性能优化)。
这在一个只做出一个决定的简化世界中是有意义的，但很少有实际系统使用这种方法。
如果必须做出一系列决策，首先选举一个领导节点，然后让领导节点协调决策会更简单、更快捷。

因此，实际系统与 Paxos 几乎没有相似之处。
每个实现都从 Paxos 开始，发现实现它的困难，然后开发出截然不同的架构。
这既费时又容易出错，理解 Paxos 的困难加剧了这个问题。
Paxos 的公式可能是证明其正确性定理的好方法，但实际实现与 Paxos 如此不同，以至于证明没有什么价值。
以下来自 Chubby 实施者的评论是非常典型的：

```text
Paxos 算法的描述与现实世界系统的需求之间存在重大差距。......最终系统将基于未经证实的协议 [4]。
```

由于这些问题，我们得出结论，Paxos 没有为系统构建或教育提供良好的基础。
考虑到共识在大型软件系统中的重要性，我们决定看看是否可以设计一种替代的共识算法，其属性比 Paxos 更好。
Raft 是那个实验的结果。

### 4 设计可理解性

我们在设计 Raft 时有几个目标：
它必须为系统构建提供完整且实用的基础，从而显着减少开发人员所需的设计工作量；
它必须在所有条件下都是安全的，并且在典型的操作条件下可用；
并且它必须对常见操作有效。
但我们最重要的目标——也是最困难的挑战——是可理解性。
这种算法必须能被大部分的受众理解。
此外，必须让受众能够对算法产生直觉，以便系统构建者可以进行在现实世界实现中进行扩展(往往是不可避免的)。

在 Raft 的设计中有很多地方我们不得不在替代方法中进行选择。
在这些情况下，我们根据可理解性评估了备选方案：解释每个备选方案有多难(例如，它的状态空间有多复杂，是否有微妙的含义？)，以及读者完全理解的难易程度，用户了解该方法及其含义吗？

我们认识到这种分析具有高度的主观性；尽管如此，我们还是使用了两种普遍适用的技术。
第一种技术是众所周知的问题分解方法：在可能的情况下，我们将问题分成可以相对独立地解决、解释和理解的单独部分。
例如，在 Raft 中，我们将领导节点选举、日志复制、安全性和成员资格更改进行分离。

我们的第二种方法是通过减少要判断的状态数量来简化状态空间，使系统更加连贯并尽可能消除不确定性。
具体来说，日志是不允许有漏洞的，Raft 限制了日志彼此不一致的方式。
尽管在大多数情况下我们试图消除不确定性，但在某些情况下，不确定性实际上提高了可理解性。
特别是，随机方法引入了不确定性，但它们倾向于通过以类似的方式处理所有可能的选择来减少状态空间(“选择任何一个；无关紧要”)。
我们使用随机化来简化 Raft 领导节点选举算法。

### 5 Raft 共识算法

![图 2：Raft 共识算法的简要总结(不包括成员变更和日志压缩)](https://i.loli.net/2021/08/05/LqwCptXDksYQ6PS.png)

> 注：左上框中的服务器行为被描述为一组独立且重复触发的规则。诸如第 5.2 节之类的部分编号指示讨论特定功能的位置。正式的规范 `[28]` 更准确地描述了算法。

Raft 是一种用于管理第 2 节中描述的形式的复制日志的算法。
图 2 以简明的形式总结了算法以供参考，图 3 列出了算法的关键特性；这些图的元素将在本节的其余部分逐个讨论。

### 6 

### 附录

#### 图 2 中文翻译

##### 状态 (State)

- 所有服务器上的持久状态

(在响应 RPC 之前更新稳定存储)

|特性|描述|
|:---:|:---:|
|currentTerm|服务器最后知道的任期号(从0开始递增)|
|votedFor|在当前任期内收到选票的候选人ID (如果没有就为 null)|
|log[]|日志条目；每个条目包含状态机的要执行命令和从领导节点处收到时的任期号|

- 所有服务器上的易失性状态

|特性|描述|
|:---:|:---:|
|commitIndex|已知的被提交的最大日志条目的索引值(从0开始递增)|
|lastApplied|被状态机执行的最大日志条目的索引值(从0开始递增)|

- 领导节点上的易失性状态

(选举后重新初始化)

|特性|描述|
|:---:|:---:|
|nextIndex[]|对于每一个服务器，记录需要发给它的下一个日志条目的索引(初始化为领导节点上一条日志的索引值 + 1)|
|matchIndex[]|对于每一个服务器，记录已经复制到该服务器的日志的最高索引值(从 0 开始递增)|

##### 附加内容 RPC (AppendEntries RPC)

此方法由领导节点调用并复制日志条目(第 5.3 节)；也用作心跳信号的传输(第 5.2 节)。

- 参数

|特性|描述|
|:---:|:---:|
|term|领导节点任期号|
|leaderId|领导节点 ID，为了其他服务器能重定向到客户端|
|prevLogIndex|紧接在新条目之前的日志条目的索引|
|prevLogTerm|最新日志之前的日志的 Leader 任期号|
|entries[]|将要存储的日志条目(表示心跳信息时为空，有时会为了效率发送超过一条)|
|leaderCommit|领导节点提交的日志条目索引|

- 结果

|特性|描述|
|:---:|:---:|
|term|目前的任期号，用于领导节点更新自己的任期号|
|success|如果其它服务器包含能够匹配上 prevLogIndex 和 prevLogTerm 的日志时为真|

- 接受者需要实现：

1. 如果 term < currentTerm返回 false(第 5.1 节)
2. 如果在 prevLogIndex 处的日志的任期号与 prevLogTerm 不匹配时，返回 false(第 5.3 节)
3. 如果一条已经存在的日志与新的冲突(index 相同但是任期号 term 不同)，则删除已经存在的日志和它之后所有的日志(第 5.3 节)
4. 添加任何在已有的日志中不存在的条目
5. 如果 leaderCommit > commitIndex，将 commitIndex 设置为 leaderCommit 和最新日志条目索引号中较小的一个

##### 投票请求 RPC (RequestVote RPC)

由候选人调用来收集选票(第 5.2 节)。

- 参数

|特性|描述|
|:---:|:---:|
|term|候选人任期|
|candidateId|要求投票的候选人|
|lastLogIndex|最后存储的候选人日志条目索引(第 5.4 节)|
|lastLogTerm|最后存储的候选人日志条目任期(第 5.4 节)|

- 结果

|特性|描述|
|:---:|:---:|
|term|目前的任期，让候选人可以更新自己|
|voteGranted|若候选人获取到了选票则为 true|

- 接收者要实现的内容

1. 如果任期 < 当前任期则返回 false(第 5.1 节)
2. 如果 votedFor 为 null 或是 CandidateId，并且候选人的日志至少与接收者的日志一样都处于最新，则批准投票(第 5.2 和 5.4 节)

##### 服务器要遵守的规则

所有服务器部分：

- 如果 commitIndex > lastApplied，就提升 lastApplied 然后接受 `log[lastApplied]` 至状态机(第 5.3 节)
- 如果 RPC 请求或相应内容中的 term T > currentTerm：就将 currentTerm = T，并转化为从属节点(第 5.1 节)

从属节点部分：

- 回应来自候选人和领导节点的 RPC 
- 如果选举超时之前没有收到来自当前领导节点的 Append Entries RPC 或候选人的投票请求：转化为候选人

候选人部分：

- 转变为候选人之后开始选举
    - 增加 currentTerm
    - 为自己投票
    - 重置选举定时器
    - 发送 RequestVote RPC 至其他节点
- 如果接收到了大多数节点的投票：转化为领导节点
- 如果接收到了新的领导节点的 AppendEntries RPC：转化为从属节点
- 如果选举超时：重新开始选举

领导节点部分：
