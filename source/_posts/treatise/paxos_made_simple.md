---
title: "Paxos Made Simple 中文翻译"
date: 2021-07-13 22:26:13
tags:
- "论文"
- "Paxos"
id: paxos_made_simple
no_word_count: true
no_toc: false
categories: 大数据
---

## Paxos Made Simple 中文翻译

作者：Leslie Lamport

[英文原文](https://www.microsoft.com/en-us/research/uploads/prod/2016/12/paxos-simple-Copy.pdf)

### 摘要

我们可以用简单的语言来描述 Paxos 算法。

> 注：本文是关于 The Part-Time Parliament 的补充说明，这篇文章实在是太难看懂了。

### 1 引言

用于实现容错分布式系统的 Paxos 算法一直被认为难以理解，可能是因为最初的介绍对许多读者来说是希腊语 `[5]`。
事实上，它是最简单和最明显的分布式算法之一。
它的核心是一个共识算法——“synod”算法 `[5]`。
下一节表明，这种共识算法几乎不可避免地遵循我们希望它满足的属性。
最后一节解释了完整的 Paxos 算法，它是通过直接将共识应用于状态机方法来构建分布式系统而获得的。
这种方法应该是众所周知的，因为它可能是最常见的主题-引用关于分布式系统理论的文章 `[4]`。

### 2 共识算法

#### 2.1 问题

假设有一组可以提出(propose)值的流程(processes)。
共识算法会确保在提议的值中选择其中的一个。
如果未提出任何值，则不应选择任何值。
如果已经选择了一个值，那么流程应该能够知道(learn)到所选的值。
共识的安全要求是：

1. 只能选择(chosen)已提议的值
2. 仅选择一个值
3. 一个过程永远不会知道一个值已经被选择，除非它实际上已经被选择

我们不会尝试指定精确的生命状态(liveness)要求。
但是，目标是确保最终选择某个提议的值，如果已选择某个值，则流程最终可以知道该值。

> 注：此处的 liveness 指的是保证集群中某些节点一直可用。

我们让共识算法中的三个角色由三类代理执行：提议者(proposers)、接受者(acceptors)和学习者(learners)。
在一个实现中，单个进程可能充当多个客户端，但是我们在这里不涉及从客户端到进程的映射。

假设客户端可以通过发送消息相互通信。
我们使用惯用的异步非拜占庭(non-Byzantine)模型，其中：

- 客户端以任意速度运行，可能会因停止而失败，也可能会重新启动。
  由于所有客户端在选择一个值后可能会失败然后重新启动，因此除非某些信息可以被失败并重新启动的客户端记住，否则解决方案是不可能的。
- 消息的传递时间可以任意长，可以复制，也可以丢失，但它们不会损坏。

#### 2.2 选择一个值

选择值的最简单方法是拥有一个单一的接受者客户端。
提议者向接受者发送提议，接受者选择它收到的第一个提议值。
虽然简单，但这个解决方案并不令人满意，因为接受者的失败使得任何进一步的进展都变得不可能。

因此，让我们尝试另一种选择值的方法。
代替单个接受者，让我们使用多个接受者客户端。
提议者将提议的值发送给一组接受者。
接受者可以接受提议的值。
当足够多的接受者集接受它时，就会选择该值。
那么多少节点才算足够多？
为了确保只选择一个值，我们可以让一个足够多的集合由大多数客户端组成这些客户端可以是系统中的任意客户端。
因为任何两个提议发送至大多数的客户端都有至少一个共同的接受者，如果一个接受者最多可以接受一个值，那算法就可以使用了。
(在许多论文中已经观察到大多数人的明显概括，显然是从 `[3]` 开始的。)

在没有失败或消息丢失的情况下，即使单个提议者仅提出一个值，我们也希望选择一个值。
这表明了如下要求：

```text
P1. An acceptor must accept the first proposal that it receives.
```

条件 1：接受者必须接受它收到的第一个提案

但是这个条件提出了一个问题。
不同的提议者可能同时提出多个值，导致每个接受者都接受了一个值，但大多数接受者都没有接受单个值的情况。
即使只有两个提议的值，如果每个值都被大约一半的接受者接受，单个接受者的失败可能会导致无法了解到具体选择了哪个值。

在条件 1 以及只有在大多数接受者接受时才选择一个值的要求意味着必须允许接受者接受多个提案。
我们通过为每个提案分配一个(自然)编号来跟踪接受者可能接受的不同提案，因此提案由提案编号和值组成。
为了防止混淆，我们要求不同的提案有不同的编号。
实现是另外的问题，所以现在我们只是假设它。
当具有该值的单个提案被大多数接受者接受时，就会选择一个值。
在这种情况下，我们说提案(及其值)已被选择。

我们可以允许选择多个提案，但我们必须保证所有被选择的提案都具有相同的值。
通过对提案编号的归纳，足以保证：

```text
P2. If a proposal with value v is chosen, then every higher-numbered proposal that is chosen has value v.
```

条件 2：如果选择了值为 v 的提案，则选择的每个编号较高的提案都具有值 v。
由于数字是完全有序的，条件 2 保证了仅选择单个值的关键安全属性。

要被选择，提案必须被至少一个接受者接受。
因此，我们可以通过满足以下条件来满足条件 2：

```text
P2a. If a proposal with value v is chosen, then every higher-numbered proposal accepted by any acceptor has value v.
```

条件 2 <sup>a</sup> ：如果选择了值为 v 的提案，则任何接受者接受的每个编号较高的提案都具有值为 v。

我们仍然保持条件 1 以确保选择某些提案。
因为通信是异步的，所以可以选择一个从未收到任何提案的特定接受者 c 的提案。
假设一个新的提议者“醒来”并发出一个具有不同值的更高编号的提议。
条件 1 要求 c 接受这个提议，违反了条件 2 <sup>a</sup>。
为了维持条件 1 和条件 2 <sup>a</sup> 我们需要对条件 2 <sup>a</sup> 进行一些补充。

```text
P2b. If a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value v.
```

条件 2 <sup>b</sup> ：如果选择了值为 v 的提案，则任何提议者发布的每个编号较高的提案都具有值为 v。

由于提议必须由提议者发出才能被接受者接受，因此条件 2 <sup>b</sup> 隐含条件 2 <sup>a</sup> ，而条件 2 <sup>a</sup>又隐含 条件 2。

为了发现如何满足条件 2 <sup>b</sup>，让我们考虑如何证明它成立。
我们假设某个编号为 m 且值为 v 的提案被选择，并表明任何编号为 n > m 的提案也具有值 v。
我们可以通过对 n 使用归纳让证明更容易，因此我们可以证明提案编号 n 的值是 v，
前提是每个提案都在 m..(n − 1)  中发布了值为 v 的数字，其中 i..j 表示从 i 到 j 的数字集合。
对于要选择的编号为 m 的提案，必须有一个由大多数接受者组成的集合 C，使得 C 中的每个接受者都接受它。
将此与归纳假设相结合，选择 m 的假设意味着：

C 中的每个接受者都接受了一个编号为 m..(n − 1) 的提案。
以及每一个在 m..(n − 1) 的提案被任何接受者接受的值为 v。

由于由大多数接受者组成的任何集合 S 至少包含 C 的一个成员，我们可以通过确保以下不变式被维护来得出编号为 n 的提案具有值 v 的结论。

```text
P2c. For any v and n, if a proposal with value v and number n is issued,
then there is a set S consisting of a majority of acceptors such that either (a) no acceptor in S has accepted any
proposal numbered less than n, or (b) v is the value of the highest-numbered proposal among all proposals numbered less
than n accepted by the acceptors in S.
```

条件 2 <sup>c</sup> ：对于任何 v 和 n，如果发布了一个值为 v 和编号为 n 的提案，则存在一个由大多数接受者组成的集合 S，
使得 (a) S 中没有接受者接受任何编号小于 n 的提案，或者 (b) v 是 S 中接受者接受的所有编号小于 n 的提案中编号最高的提案的值。

因此，我们可以通过保持条件 2 <sup>c</sup> 的不变性来满足条件 2 <sup>b</sup> 。

为了保持条件 2 <sup>c</sup> 的不变性，想要发布编号为 n 的提案的提案者必须知道编号小于 n 的最高编号提案(如果有)，
该提案已经或将被某些多数接受者中的每个接受者接受。
了解已经接受的提案很容易但很难预测未来的接受度。
提议者不是试图预测未来，而是通过提取不会有任何此类接受的承诺来控制它。
换句话说，提议者要求接受者不再接受任何编号小于 n 的提议。
这导致了以下用于发布提案的算法。

1. 提议者选择一个新的提议编号 n 并向一组接受者的每个成员发送请求，要求其响应：
    1. 承诺不再接受编号小于 n 的提案
    2. 其已接受的最大数目小于 n 的提案(如果有)

我将这样的请求称为编号为 n 的准备请求。

2. 如果提议者收到来自大多数接受者的请求响应，那么它可以发出编号为 n 且值为 v 的提议，其中 v 是响应中编号最高的提议的值，
   或者是提议者选择的任何值 如果响应者报告没有提案。

提议者通过向某组接受者发送提议被接受的请求来发布提议。
(这不必是响应初始请求的同一组接受者。)
我们称之为接受请求。

这描述了提议者的算法。
那接受者呢？
它可以接收来自提议者的两种请求：准备请求和接受请求。
接受者可以忽略任何请求而不会影响安全性。
所以，我们只需要说明什么时候允许响应请求。
它总是可以响应准备请求。
它可以响应接受请求，接受提议，如果它没有承诺不接受。
换句话说：

```text
P1a. An acceptor can accept a proposal numbered n iff it has not responded to a prepare request having a number greater than n.
```

条件 1 <sup>a</sup> ：接受者可以接受编号为 n 的提议，如果它没有响应编号大于 n 的准备请求。
我们可以发现条件 1 包含条件 1 <sup>a</sup> 。

假设一个接受者收到一个编号为 n 的准备请求，但它已经响应了一个编号大于 n 的准备请求，从而承诺不接受任何编号为 n 的新提案。
那么接受者就没有理由响应新的准备请求，因为它不会接受提议者想要发布的编号为 n 的提案。
所以我们让接受者忽略这样的准备请求。
我们还让它忽略对已经接受的提案的准备请求。

通过这种优化，接受者只需要记住它曾经接受过的最高编号的提议和它已经响应的最高编号的准备请求的编号。
因为无论失败如何条件 2 <sup>c</sup> 都必须保持不变，所以即使经历失败然后重新启动，接受者也必须记住此信息。

将提议者和接受者的动作放在一起，我们看到该算法在以下两个阶段运行。

**第一阶段** 

(a) 提议者选择一个提议编号 n 并向大多数接受者发送编号为 n 的准备请求。
(b) 如果接受者收到的准备请求的数量 n 大于它已经响应的任何准备请求的数量，
    那么它会以承诺不再接受任何编号小于 n 的提案和编号最高的提案来响应该请求(如果有)它已接受。

**第二阶段**

(a) 如果提议者从大多数接受者那里收到对其准备请求（编号为 n）的响应，那么它会向这些接受者中的每一个发送接受请求，
    以获得编号为 n 且值为 v 的提议，其中 v 是最高的值 - 在响应中编号的提案，或者如果响应没有报告提案，则为任何值。
(b) 如果接受者收到对编号为 n 的提案的接受请求，则它接受该提案，除非它已经响应了编号大于 n 的准备请求。

一个提议者可以提出多个提议，只要它遵循每个提议的算法即可。
它可以随时放弃协议中间的提案。
(即使对提案的请求和/或响应可能在提案被放弃很久之后才到达目的地，但仍保持正确性。)
如果某个提议者已经开始尝试发布更高编号的提议，那么放弃提议可能是个好主意。
因此，如果一个接受者因为已经收到了一个更高编号的准备请求而忽略了一个准备或接受请求，那么它可能应该通知提议者，然后提议者应该放弃它的提议。
这是不影响正确性的性能优化。

#### 2.3 知道被选择的值

