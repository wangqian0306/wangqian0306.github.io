---
title: "Paxos Made Simple 中文翻译"
date: 2021-07-13 22:26:13
tags:
- "论文"
- "Paxos"
id: paxos_made_simple
no_word_count: true
no_toc: false
categories: 大数据
---

## Paxos Made Simple 中文翻译

作者：Leslie Lamport

[英文原文](https://www.microsoft.com/en-us/research/uploads/prod/2016/12/paxos-simple-Copy.pdf)

### 摘要

我们可以用简单的语言来描述 Paxos 算法。

> 注：本文是关于 The Part-Time Parliament 的补充说明，这篇文章实在是太难看懂了。

### 1 引言

用于实现容错分布式系统的 Paxos 算法一直被认为难以理解，可能是因为最初的介绍对许多读者来说是希腊语 `[5]`。
事实上，它是最简单和最明显的分布式算法之一。
它的核心是一个共识算法——“synod”算法 `[5]`。
下一节表明，这种共识算法几乎不可避免地遵循我们希望它满足的属性。
最后一节解释了完整的 Paxos 算法，它是通过直接将共识应用于状态机方法来构建分布式系统而获得的。
这种方法应该是众所周知的，因为它可能是最常见的主题-引用关于分布式系统理论的文章 `[4]`。

### 2 共识算法

#### 2.1 问题

假设有一组可以提出(propose)值的流程(processes)。
共识算法会确保在提议的值中选择其中的一个。
如果未提出任何值，则不应选择任何值。
如果已经选择了一个值，那么流程应该能够知道(learn)到所选的值。
共识的安全要求是：

1. 只能选择(chosen)已提议的值
2. 仅选择一个值
3. 一个过程永远不会知道一个值已经被选择，除非它实际上已经被选择

我们不会尝试指定精确的生命状态(liveness)要求。
但是，目标是确保最终选择某个提议的值，如果已选择某个值，则流程最终可以知道该值。

> 注：此处的 liveness 指的是保证集群中某些节点一直可用。

我们让共识算法中的三个角色由三类代理执行：提议者(proposers)、接受者(acceptors)和学习者(learners)。
在一个实现中，单个进程可能充当多个客户端，但是我们在这里不涉及从客户端到进程的映射。

假设客户端可以通过发送消息相互通信。
我们使用惯用的异步非拜占庭(non-Byzantine)模型，其中：

- 客户端以任意速度运行，可能会因停止而失败，也可能会重新启动。
  由于所有客户端在选择一个值后可能会失败然后重新启动，因此除非某些信息可以被失败并重新启动的客户端记住，否则解决方案是不可能的。
- 消息的传递时间可以任意长，可以复制，也可以丢失，但它们不会损坏。

#### 2.2 选择一个值

选择值的最简单方法是拥有一个单一的接受者客户端。
提议者向接受者发送提议，接受者选择它收到的第一个提议值。
虽然简单，但这个解决方案并不令人满意，因为接受者的失败使得任何进一步的进展都变得不可能。

因此，让我们尝试另一种选择值的方法。
代替单个接受者，让我们使用多个接受者客户端。
提议者将提议的值发送给一组接受者。
接受者可以接受提议的值。
当足够多的接受者集接受它时，就会选择该值。
那么多少节点才算足够多？
为了确保只选择一个值，我们可以让一个足够多的集合由大多数客户端组成这些客户端可以是系统中的任意客户端。
因为任何两个提议发送至大多数的客户端都有至少一个共同的接受者，如果一个接受者最多可以接受一个值，那算法就可以使用了。
(在许多论文中已经观察到大多数人的明显概括，显然是从 `[3]` 开始的。)

在没有失败或消息丢失的情况下，即使单个提议者仅提出一个值，我们也希望选择一个值。
这表明了如下要求：

```text
P1. An acceptor must accept the first proposal that it receives.
```

条件 1：接受者必须接受它收到的第一个提案

但是这个条件提出了一个问题。
不同的提议者可能同时提出多个值，导致每个接受者都接受了一个值，但大多数接受者都没有接受单个值的情况。
即使只有两个提议的值，如果每个值都被大约一半的接受者接受，单个接受者的失败可能会导致无法了解到具体选择了哪个值。

在条件 1 以及只有在大多数接受者接受时才选择一个值的要求意味着必须允许接受者接受多个提案。
我们通过为每个提案分配一个(自然)编号来跟踪接受者可能接受的不同提案，因此提案由提案编号和值组成。
为了防止混淆，我们要求不同的提案有不同的编号。
实现是另外的问题，所以现在我们只是假设它。
当具有该值的单个提案被大多数接受者接受时，就会选择一个值。
在这种情况下，我们说提案(及其值)已被选择。

我们可以允许选择多个提案，但我们必须保证所有被选择的提案都具有相同的值。
通过对提案编号的归纳，足以保证：

```text
P2. If a proposal with value v is chosen, then every higher-numbered proposal that is chosen has value v.
```

条件 2：如果选择了值为 v 的提案，则选择的每个编号较高的提案都具有值 v。
由于数字是完全有序的，条件 2 保证了仅选择单个值的关键安全属性。

要被选择，提案必须被至少一个接受者接受。
因此，我们可以通过满足以下条件来满足条件 2：

```text
P2a. If a proposal with value v is chosen, then every higher-numbered proposal accepted by any acceptor has value v.
```

条件 2 <sup>a</sup> ：如果选择了值为 v 的提案，则任何接受者接受的每个编号较高的提案都具有值为 v。

我们仍然保持条件 1 以确保选择某些提案。
因为通信是异步的，所以可以选择一个从未收到任何提案的特定接受者 c 的提案。
假设一个新的提议者“醒来”并发出一个具有不同值的更高编号的提议。
条件 1 要求 c 接受这个提议，违反了条件 2 <sup>a</sup>。
为了维持条件 1 和条件 2 <sup>a</sup> 我们需要对条件 2 <sup>a</sup> 进行一些补充。

```text
P2b. If a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value v.
```

条件 2 <sup>b</sup> ：如果选择了值为 v 的提案，则任何提议者发布的每个编号较高的提案都具有值为 v。

由于提议必须由提议者发出才能被接受者接受，因此条件 2 <sup>b</sup> 隐含条件 2 <sup>a</sup> ，而条件 2 <sup>a</sup>又隐含 条件 2。

为了发现如何满足条件 2 <sup>b</sup>，让我们考虑如何证明它成立。
我们假设某个编号为 m 且值为 v 的提案被选择，并表明任何编号为 n > m 的提案也具有值 v。
我们可以通过对 n 使用归纳让证明更容易，因此我们可以证明提案编号 n 的值是 v，
前提是每个提案都在 m..(n − 1)  中发布了值为 v 的数字，其中 i..j 表示从 i 到 j 的数字集合。
对于要选择的编号为 m 的提案，必须有一个由大多数接受者组成的集合 C，使得 C 中的每个接受者都接受它。
将此与归纳假设相结合，选择 m 的假设意味着：

C 中的每个接受者都接受了一个编号为 m..(n − 1) 的提案。
以及每一个在 m..(n − 1) 的提案被任何接受者接受的值为 v。

由于由大多数接受者组成的任何集合 S 至少包含 C 的一个成员，我们可以通过确保以下不变式被维护来得出编号为 n 的提案具有值 v 的结论。

```text
P2c. For any v and n, if a proposal with value v and number n is issued,
then there is a set S consisting of a majority of acceptors such that either (a) no acceptor in S has accepted any
proposal numbered less than n, or (b) v is the value of the highest-numbered proposal among all proposals numbered less
than n accepted by the acceptors in S.
```

条件 2 <sup>c</sup> ：对于任何 v 和 n，如果发布了一个值为 v 和编号为 n 的提案，则存在一个由大多数接受者组成的集合 S，
使得 (a) S 中没有接受者接受任何编号小于 n 的提案，或者 (b) v 是 S 中接受者接受的所有编号小于 n 的提案中编号最高的提案的值。

因此，我们可以通过保持条件 2 <sup>c</sup> 的不变性来满足条件 2 <sup>b</sup> 。

为了保持条件 2 <sup>c</sup> 的不变性，想要发布编号为 n 的提案的提案者必须知道编号小于 n 的最高编号提案(如果有)，
该提案已经或将被某些多数接受者中的每个接受者接受。
了解已经接受的提案很容易但很难预测未来的接受度。
提议者不是试图预测未来，而是通过提取不会有任何此类接受的承诺来控制它。
换句话说，提议者要求接受者不再接受任何编号小于 n 的提议。
这导致了以下用于发布提案的算法。


