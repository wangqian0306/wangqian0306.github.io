---
title: JAVA 当中的锁
date: 2020-06-18 21:54:12
tags: "JAVA"
id: java lock
no_word_count: true
no_toc: false
categories: JAVA
---

## 锁的类型与实现方式

- 线程是否要锁同步资源
  - 锁住
    - 悲观锁 (synchronized，接口Lock的实现类)
  - 不锁
    - 乐观锁 (CAS算法)
- 被锁导致同步资源失败，线程是否阻塞
  - 阻塞
    - 自旋锁
  - 不阻塞
    - 适应性锁
- 多个线程竞争同步资源的流程细节有没有区别
  - 不锁住资源，多线程中只有一个能成功修改资源其他的线程会重试
    - 无锁
  - 同一个线程执行同步资源时自动获取资源
    - 偏向锁
  - 多个线程竞争同步资源时，没有获取资源的线程自旋等待锁被释放
    - 轻量级锁
  - 多个线程竞争同步资源时，没有获取资源的线程阻塞等待唤醒
    - 重量级锁
- 多个线程竞争锁时是否要排队
  - 排队
    - 公平锁
  - 先尝试插队，插队失败再排队
    - 非公平锁
- 一个线程的多个流程能不能获取同一把锁
  - 能
    - 可重入锁
  - 不能
    - 非可重入锁
  - 多个线程能不能共享一把锁
    - 能
      - 共享锁
    - 不能
      - 排他锁

## CAS 算法及 ABA 问题

Compare And Set（CAS）即比较与交换算法是通过

- 内存地址
- 操作对象原始值
- 目标值

三个内容的对比来实现功能的。而在特殊的情况下由于原始值可能经历过了多次修改又变回了和原来
一样的值，在这种情况下再去做修改就不符合实际场景了，这样的问题叫ABA问题。

> 注：在对比时加入数据的版本号即可解决ABA问题。

## synchronized 关键字的使用

synchronized 关键字有以下三种用法

1. 同步实例方法，锁当前实例对象
2. 同步类方法(静态方法)，锁当前类对象
3. 同步代码块，锁括号中的对象

### 锁的膨胀升级过程

- 在只有一个线程进入临界区时会采用偏向锁。
- 在多线程未竞争或者竞争不激烈时采用轻量级锁。
- 在多线程竞争时采用重量级锁

<!--## 对象的内存结构-->

<!--对象在内存中分为对象头和实际数据两个部分：-->

<!--对象头中包含：-->

<!--- hash码-->
<!--- 对象所处的年代-->
<!--- 对象锁-->
<!--- 锁的状态标志-->
<!--- 偏向锁ID-->
<!--- 偏向时间-->

<!--对象实际数据部分包含：-->

<!--- 成员变量-->
<!--- 方法-->

