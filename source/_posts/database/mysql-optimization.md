---
title: MySQL 优化
date: 2024-12-09 22:12:59
tags: "MySQL"
id: mysql-optimization
no_word_count: true
no_toc: false
categories: MySQL
---

## MySQL 优化

### 简介

数据库性能取决于数据库中的几个因素 级别，例如 tables、queries 和 configuration settings。这些软件结构导致硬件级别产生不同的 CPU 指令和 I/O 操作，为了优化性能需要将操作数进可能缩减。在提高数据库性能时，首先需要试用设计上的基础规则和软件的指导手册，并采用时间所为评判工具来进行优化。想成为专家，可以更多地了解软件内部发生的事情， 并开始测量 CPU 周期和 I/O 操作等内容。

典型用户的目标是从其现有的软件和硬件配置中获得最佳数据库性能。高级用户寻找机会改进 MySQL 软件本身，或开发自己的存储引擎和硬件设备来扩展 MySQL 生态系统。在官方文档中针对优化方式进行了如下分类：

- 在数据库级别进行优化
- 在硬件级别进行优化
- 平衡可移植性和性能(略)

### 在数据库级别进行优化

从基础设计上进行优化是最主要的提升方向，具体项目如下：

- 表结构(tables structure)
- 索引(indexes)
- 存储引擎(storage engine)
- 行格式(row format)
- 锁策略(locking strategy)
- 缓存大小(memory areas used for caching)

在上述优化执行前可以先考虑通过优化 SQL 的角度来提升检索速度。

#### 优化 SQL 语句

在优化 SQL 时主要遵循的思路是：

- 利用索引
- 隔离并优化查询的任何部分
- 减少全表扫描
- 让优化器读取到最新的表结构
- 了解存储引擎的优化技术、索引技术和配置参数
- 调整 MySQL 缓存中关于内存区域的大小和配置
- 减少缓存的大小
- 处理锁的问题

> 注：由于此处内容过多且杂乱，此时暂不整理。如有需求请参照 [Optimizing SQL Statements](https://dev.mysql.com/doc/refman/8.0/en/statement-optimization.html)

#### 优化索引

大多数 MySQL 索引(PRIMARY KEY ,UNIQUE ,INDEX, FULLTEXT)存储在 B 树(B-Trees,统称，一般应该是 B+ 树)。例外： SPECIAL 类型的索引使用 R 树; MEMORY table 还支持哈希索引; InnoDB 对 FULLTEXT 索引使用倒排索引。

在索引使用上遵循如下规则：

- 如果有多列索引，检索时要从左往右进行索引拼接。
- 如果需要跨表，最好让链接列具有相同的数据类型和大小且如果是字符串需要相同的字符集。
- 如果是 SPATIAL 索引需要指定 SRID(Spatial Reference System Identifier, 例如：EPSG:4326)。
- 在遇到非二进制数据时需要确保字段编码后长度小于 767 字节。

在检索时可以使用 Explain 语句查看检索方式，优化查询逻辑。

MySQL 存储引擎还会通过读取表统计信息的方式来对查询进行优化，索引对应的数据条目数如果太多则 MySQL 可能不会使用该索引。索引对应的数据条目数可以通过 `SHOW INDEX` 语句查看，它会显示基于 N/S 的基数值，其中 N 是表中的行数，S 是索引对应的数据条目大小。

在使用索引时 InnoDB 存储引擎默认打开了索引扩展功能，在优化器中会执行索引扩展操作，将二级索引拼接在主键前，在使用时可以检查是否采用此功能。

为了减少数据扫描，可以在创建索引时指定排序方式，例如：`CREATE INDEX idx_name ON table_name (col1 ASC ,col2 DESC)`。

> 注：在进行索引优化时如果表比较大删除和重新添加索引的成本会很高，此时可以先将其设置为隐形索引，然后再去检查 optimizer 是否使用隐形索引做检索条件，将其关闭即可进行测试。

#### 优化数据结构

数据结构的优化要安排在设计阶段，目的是将表使用的数据空间尽可能缩小。此时花费的内存也会减少，并且索引也会相对较小检索速度也就会提升。

MySQL 支持许多不同的存储引擎(表类型)和 行格式。对于每个表，可以单独指定存储引擎和要使用的索引方法。

主要的方法如下：

- 表列(Table Columns)
  - 选择合适的数据类型，比方说 MEDIUMINT 比 INT 使用的空间少 25%。
  - 如有可能，请将列设置为 NOT NULL。它支持更好的使用索引并消除测试每个值为 NULL 的开销并缩减 1 位的空间。
- 行格式(Row Format)
  - 在不同的存储引擎中支持了不同的行格式，如果使用紧凑的行格式可能会增加 CPU 负载但是会减少磁盘负载。需结合具体需求进行确定。
  - 对于 MyISAM 表，如果没有可变长度的列(VARCHAR, TEXT, BLOB)，可以使用固定大小的行格式(FIXED)。这样会更快，但是浪费了空间。
- 索引(Indexes)
  - 表的主索引应尽可能短。
  - 仅创建提高查询性能所需的索引。索引的 Key 应当以检索频率进行排序，最左侧的应该是常见且经常重复的列。
  - 如果说长字符串的前 N 位已经足够表达唯一性了，后续内容可以忽略则可以在创建索引的时候指定位数。
- 链接(Joins)
  - 将频繁被查询的数据和不用于查询只展示的数据进行分离。
  - 在具有相同数据类型的不同表中声明具有相同信息的列，以加快基于相应列的连接。
  - 保持列名简单，以便在不同的表中使用相同的名称并简化联接查询。
- 范式化(Normalization)
  - 通常，尽量保持所有数据不冗余。
  - 如果速度比磁盘空间和保留多个数据副本的维护成本更重要，则可以考虑冗余。

在选择列数据类型时可以遵循如下逻辑：

- 数值型
  - 优先选择用数值型进行存储而不要使用字符串。
  - 如果是数值数据，在实时链接下比读取文件快。
- 字符型
  - 在不需要语言特行排序和比较特性的情况下，可以使用二进制（binary）排序规则（collation）来提高比较和排序操作的性能。
  - 在比较不同列的值时，尽可能使用相同的字符集和排序规则声明这些列，以避免在运行查询时进行字符串转换。
  - 对于内容小于 8KB 的列值，请使用二进制 VARCHAR 而不是 BLOB。
  - 如果表包含字符串列，例如 name 和 address，但许多查询不会检索这些列， 考虑将字符串列拆分为单独的 table 并使用带有外键的联接查询。
  - 如果使用随机的值作为主键(类似 UUID)时最好在前面附加时间数据，便于 InnoDB 索引插入和检索。
- BLOB 型
  - 存储包含文本数据的大型 blob 时， 首先考虑压缩它。
  - 对于具有多个列的表，为了减少不使用 BLOB 列的查询的内存需求，可以考虑将 BLOB 列拆分为一个单独的表，并在需要时用联接查询引用它。
  - 可以将 BLOB 数据存储在独立的存储设备或单独的数据库实例上。
  - 可以将列值的哈希值存储在单独的列中，为该列编制索引，并在查询中测试哈希值，而不是针对很长的文本字符串测试内容是否相同。

### 在硬件级别进行优化

任何数据库应用程序最终都会达到硬件限制，因为 数据库变得越来越繁忙。DBA 必须评估 可以调整应用程序或重新配置服务器 要避免这些 瓶颈，或者是否需要更多硬件资源。系统瓶颈通常来自以下来源：

- 磁盘查找(Disk seeks)
- 磁盘读取和写入(Disk reading and writing)
- CPU 周期(CPU cycles)
- 内存带宽(Memory bandwidth)

### 参考资料

[官方文档](https://dev.mysql.com/doc/refman/8.0/en/optimization.html)
